
print("DEBUG: Script execution started (v9.5 - GUI Default Open).")

-- ========== Roblox Services ==========
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
print("DEBUG: Services loaded.")

-- ========== Player & Camera ==========
local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then warn("DEBUG: FATAL - LocalPlayer not found!") return end
print("DEBUG: LocalPlayer found:", LocalPlayer.Name)
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
if not PlayerGui then warn("DEBUG: FATAL - PlayerGui not found after wait!") return end
print("DEBUG: PlayerGui loaded.")
local Camera = Workspace.CurrentCamera
if not Camera then warn("DEBUG: FATAL - Workspace.CurrentCamera not found!") return end
print("DEBUG: Camera found.")

-- ========== Configuration ==========
local DEFAULT_AIMBOT_HOLD_KEY = Enum.UserInputType.MouseButton2
local TOGGLE_GUI_KEY = Enum.KeyCode.Insert
local CANCEL_BIND_KEY = Enum.KeyCode.Escape
local TELEPORT_KEY = Enum.KeyCode.H          -- 切換 持續傳送
local ANTI_AIM_KEY = Enum.KeyCode.N          -- 切換 反瞄準抖動
local FLIGHT_TOGGLE_KEY = Enum.KeyCode.V     -- 切換 飛行模式
local TELEPORT_BEHIND_DISTANCE = 3
local ANTI_AIM_RADIUS = 5
local FLIGHT_SPEED = 50                      -- 水平飛行速度
local FLIGHT_VERTICAL_SPEED = 30             -- 垂直飛行速度

-- Visual Cue Dot / ESP Config
local DOT_COLOR_NOLOCK=Color3.fromRGB(255,255,255); local DOT_COLOR_LOCKED=Color3.fromRGB(255,0,0); local DOT_SIZE=Vector2.new(4,4)
local ESP_BOX_COLOR=Color3.fromRGB(0,150,255); local ESP_TEXT_COLOR=Color3.fromRGB(255,255,255); local ESP_TEXT_SIZE=14; local ESP_HEALTH_SIZE=12
print("DEBUG: Configuration set.")

-- ========== State Variables ==========
local aimbotEnabled = true
local espEnabled = true
local teleportModeActive = false
local antiAimActive = false
local flightActive = false
local guiVisible = true -- **** MODIFICATION 1: Set GUI to visible by default ****
local currentAimbotHoldKey = DEFAULT_AIMBOT_HOLD_KEY
local currentlyBindingKey = nil
local espElements = {}
-- Body Mover References
local bodyVelocity = nil
local bodyGyro = nil
print("DEBUG: State variables initialized (guiVisible=true).")

-- ========== GUI Creation (Control Panel - 中文) ==========
print("DEBUG: Creating Control Panel GUI...")
local controlPanelGui=Instance.new("ScreenGui"); controlPanelGui.Name="AimbotESPControlPanel"; controlPanelGui.ResetOnSpawn=false; controlPanelGui.ZIndexBehavior=Enum.ZIndexBehavior.Sibling; controlPanelGui.Parent=PlayerGui
local mainFrame=Instance.new("Frame"); mainFrame.Name="MainFrame"; mainFrame.Size=UDim2.new(0,300,0,265); mainFrame.Position=UDim2.new(0,10,0,10); mainFrame.BackgroundColor3=Color3.fromRGB(40,40,40); mainFrame.BorderColor3=Color3.fromRGB(80,80,80); mainFrame.BorderSizePixel=2; mainFrame.Active=true; mainFrame.Draggable=true;
mainFrame.Visible=guiVisible; -- This line now makes the frame visible initially because guiVisible is true
mainFrame.Parent=controlPanelGui
-- (Rest of GUI elements remain the same as your provided code)
local titleLabel=Instance.new("TextLabel"); titleLabel.Name="Title"; titleLabel.Parent=mainFrame; titleLabel.Text="niggaLOSE"; titleLabel.Size=UDim2.new(1,0,0,30); titleLabel.BackgroundColor3=Color3.fromRGB(50,50,50); titleLabel.TextColor3=Color3.fromRGB(255,255,255); titleLabel.Font=Enum.Font.SourceSansBold; titleLabel.TextSize=18; titleLabel.TextXAlignment=Enum.TextXAlignment.Center
local enableAimbotCheckbox=Instance.new("TextButton"); enableAimbotCheckbox.Name="EnableAimbotCheckbox"; enableAimbotCheckbox.Parent=mainFrame; enableAimbotCheckbox.Size=UDim2.new(1,-20,0,25); enableAimbotCheckbox.Position=UDim2.new(0,10,0,40); enableAimbotCheckbox.BackgroundColor3=Color3.fromRGB(60,60,60); enableAimbotCheckbox.BorderSizePixel=1; enableAimbotCheckbox.Font=Enum.Font.SourceSans; enableAimbotCheckbox.TextSize=16
local enableEspCheckbox=Instance.new("TextButton"); enableEspCheckbox.Name="EnableEspCheckbox"; enableEspCheckbox.Parent=mainFrame; enableEspCheckbox.Size=UDim2.new(1,-20,0,25); enableEspCheckbox.Position=UDim2.new(0,10,0,70); enableEspCheckbox.BackgroundColor3=Color3.fromRGB(60,60,60); enableEspCheckbox.BorderSizePixel=1; enableEspCheckbox.Font=Enum.Font.SourceSans; enableEspCheckbox.TextSize=16
local aimKeyLabel=Instance.new("TextLabel"); aimKeyLabel.Name="AimKeyLabel"; aimKeyLabel.Parent=mainFrame; aimKeyLabel.Size=UDim2.new(0.6,-15,0,25); aimKeyLabel.Position=UDim2.new(0,10,0,105); aimKeyLabel.BackgroundTransparency=1; aimKeyLabel.TextColor3=Color3.fromRGB(180,180,180); aimKeyLabel.Font=Enum.Font.SourceSans; aimKeyLabel.TextSize=14; aimKeyLabel.TextXAlignment=Enum.TextXAlignment.Left
local changeAimKeyButton=Instance.new("TextButton"); changeAimKeyButton.Name="ChangeAimKey"; changeAimKeyButton.Parent=mainFrame; changeAimKeyButton.Size=UDim2.new(0.4,-15,0,25); changeAimKeyButton.Position=UDim2.new(0.6,0,0,105); changeAimKeyButton.BackgroundColor3=Color3.fromRGB(70,70,100); changeAimKeyButton.BorderSizePixel=1; changeAimKeyButton.TextColor3=Color3.fromRGB(220,220,255); changeAimKeyButton.Font=Enum.Font.SourceSans; changeAimKeyButton.TextSize=14; changeAimKeyButton.Text="更改"
local teleportInfoLabel=Instance.new("TextLabel"); teleportInfoLabel.Name="TeleportInfoLabel"; teleportInfoLabel.Parent=mainFrame; teleportInfoLabel.Size=UDim2.new(1,-20,0,20); teleportInfoLabel.Position=UDim2.new(0,10,0,135); teleportInfoLabel.BackgroundTransparency=1; teleportInfoLabel.TextColor3=Color3.fromRGB(180,180,180); teleportInfoLabel.Font=Enum.Font.SourceSans; teleportInfoLabel.TextSize=14; teleportInfoLabel.TextXAlignment=Enum.TextXAlignment.Left; teleportInfoLabel.Text = "按 H 切換持續傳送到敵人背後 (反武士刀)"
local antiAimInfoLabel=Instance.new("TextLabel"); antiAimInfoLabel.Name="AntiAimInfoLabel"; antiAimInfoLabel.Parent=mainFrame; antiAimInfoLabel.Size=UDim2.new(1,-20,0,20); antiAimInfoLabel.Position=UDim2.new(0,10,0,155); antiAimInfoLabel.BackgroundTransparency=1; antiAimInfoLabel.TextColor3=Color3.fromRGB(180,180,180); antiAimInfoLabel.Font=Enum.Font.SourceSans; antiAimInfoLabel.TextSize=14; antiAimInfoLabel.TextXAlignment=Enum.TextXAlignment.Left; antiAimInfoLabel.Text = "按 N 切換反瞄準模式 (亂飛亂tp)"
local flightInfoLabel=Instance.new("TextLabel"); flightInfoLabel.Name="FlightInfoLabel"; flightInfoLabel.Parent=mainFrame; flightInfoLabel.Size=UDim2.new(1,-20,0,20); flightInfoLabel.Position=UDim2.new(0,10,0,175); flightInfoLabel.BackgroundTransparency=1; flightInfoLabel.TextColor3=Color3.fromRGB(180,180,180); flightInfoLabel.Font=Enum.Font.SourceSans; flightInfoLabel.TextSize=14; flightInfoLabel.TextXAlignment=Enum.TextXAlignment.Left; flightInfoLabel.Text = "按 V 切換飛行模式 (WASD+空格/左Shift)"
local instructionLabel=Instance.new("TextLabel"); instructionLabel.Name="InstructionLabel"; instructionLabel.Parent=mainFrame; instructionLabel.Size=UDim2.new(1,-20,0,40); instructionLabel.Position=UDim2.new(0,10,0,200); instructionLabel.BackgroundTransparency=1; instructionLabel.TextColor3=Color3.fromRGB(150,150,150); instructionLabel.Font=Enum.Font.SourceSansItalic; instructionLabel.TextSize=12; instructionLabel.TextWrapped=true; instructionLabel.Text="需要自動打請打開外部必要.ahk。\n中心點始終顯示。\nIns切換面板, Esc取消綁定。"
print("DEBUG: Control Panel GUI created.")

-- ========== GUI Creation (Visual Cue Dot) ==========
-- (No changes needed here)
print("DEBUG: Creating Visual Cue GUI...")
local cueGui=Instance.new("ScreenGui"); cueGui.Name="AimbotVisualCueGui"; cueGui.ResetOnSpawn=false; cueGui.IgnoreGuiInset=true; cueGui.ZIndexBehavior=Enum.ZIndexBehavior.Global; cueGui.DisplayOrder=1000; cueGui.Parent=CoreGui
local cueDot=Instance.new("Frame"); cueDot.Name="CueDot"; cueDot.Size=UDim2.fromOffset(DOT_SIZE.X,DOT_SIZE.Y); cueDot.AnchorPoint=Vector2.new(0.5,0.5); cueDot.Position=UDim2.new(0.5,0,0.5,0); cueDot.BackgroundColor3=DOT_COLOR_NOLOCK; cueDot.BorderSizePixel=0; cueDot.Visible=true; cueDot.Parent=cueGui
local dotCorner=Instance.new("UICorner"); dotCorner.CornerRadius=UDim.new(0.5,0); dotCorner.Parent=cueDot
print("DEBUG: Visual Cue GUI created.")

-- ========== Helper Functions ==========
-- (No changes needed here)
print("DEBUG: Defining Helper Functions...")
local function getKeyName(inputObject) if not inputObject then return "NONE" end local success, name = pcall(function() if inputObject:IsA("KeyCode") then return inputObject.Name elseif inputObject:IsA("UserInputType") then if inputObject==Enum.UserInputType.MouseButton1 then return "MOUSE1" elseif inputObject==Enum.UserInputType.MouseButton2 then return "MOUSE2" elseif inputObject==Enum.UserInputType.MouseButton3 then return "MOUSE3" else return inputObject.Name end end return "UNKNOWN" end) return success and name or "ERROR" end
local function updateCheckboxText() local success = pcall(function() if aimbotEnabled then enableAimbotCheckbox.Text = "啟用 自動瞄準: [ ON ]"; enableAimbotCheckbox.TextColor3 = Color3.fromRGB(0, 255, 0) else enableAimbotCheckbox.Text = "啟用 自動瞄準: [ OFF ]"; enableAimbotCheckbox.TextColor3 = Color3.fromRGB(255, 0, 0) end; if espEnabled then enableEspCheckbox.Text = "啟用 ESP透視: [ ON ]"; enableEspCheckbox.TextColor3 = Color3.fromRGB(0, 255, 0) else enableEspCheckbox.Text = "啟用 ESP透視: [ OFF ]"; enableEspCheckbox.TextColor3 = Color3.fromRGB(255, 0, 0) end end) if not success then warn("Error updating checkbox text") end end
local function updateKeybindDisplay() local success = pcall(function() aimKeyLabel.Text = "瞄準鍵: " .. getKeyName(currentAimbotHoldKey) end) if not success then warn("Error updating keybind display") end end
local function resetButtonStates() local success = pcall(function() changeAimKeyButton.Text = "更改"; changeAimKeyButton.BackgroundColor3 = Color3.fromRGB(70, 70, 100); currentlyBindingKey = nil end) if not success then warn("Error resetting button states") end end
pcall(updateCheckboxText); pcall(updateKeybindDisplay)
print("DEBUG: Helper Functions defined.")

-- ========== GUI Event Handlers ==========
-- (No changes needed here)
print("DEBUG: Connecting GUI Event Handlers...")
local aimCbConn, espCbConn, btnConn
aimCbConn = enableAimbotCheckbox.MouseButton1Click:Connect(function() local success = pcall(function() print("DEBUG: Aimbot Checkbox Clicked."); aimbotEnabled = not aimbotEnabled; updateCheckboxText(); end) if not success then warn("Error in aimbot checkbox click handler") end end)
espCbConn = enableEspCheckbox.MouseButton1Click:Connect(function() local success = pcall(function() print("DEBUG: ESP Checkbox Clicked."); espEnabled = not espEnabled; updateCheckboxText(); if not espEnabled then for _, elements in pairs(espElements) do if elements.Box then elements.Box.Visible = false end; if elements.Name then elements.Name.Visible = false end; if elements.Health then elements.Health.Visible = false end end end end) if not success then warn("Error in ESP checkbox click handler") end end)
btnConn = changeAimKeyButton.MouseButton1Click:Connect(function() local success = pcall(function() print("DEBUG: Change Key Button Clicked."); if currentlyBindingKey then return end; currentlyBindingKey = "aim"; changeAimKeyButton.Text = "按下按鍵..."; changeAimKeyButton.BackgroundColor3 = Color3.fromRGB(100, 100, 70) end) if not success then warn("Error in change key button handler") end end)
print("DEBUG: GUI Event Handlers connected.")

-- ========== Core Logic ==========
-- (No changes needed in these functions)
print("DEBUG: Defining Core Logic Functions...")
local function getNearestPlayer() local closestPlayer=nil; local shortestDistance=math.huge; local localChar=LocalPlayer.Character; local localHRP=localChar and localChar:FindFirstChild("HumanoidRootPart"); if not localChar or not localHRP then return nil end; for _, player in pairs(Players:GetPlayers()) do local char=player.Character; local hrp=char and char:FindFirstChild("HumanoidRootPart"); local head=char and char:FindFirstChild("Head"); local hum=char and char:FindFirstChildOfClass("Humanoid"); if player~=LocalPlayer and hrp and head and hum and hum.Health>0 then local distance=(hrp.Position-localHRP.Position).Magnitude; if distance<shortestDistance then local rayOrigin=Camera.CFrame.Position; local rayDirection=(head.Position-rayOrigin).Unit*distance; local raycastParams=RaycastParams.new(); raycastParams.FilterDescendantsInstances={localChar,Camera,controlPanelGui,cueGui}; raycastParams.FilterType=Enum.RaycastFilterType.Exclude; local raycastResult=Workspace:Raycast(rayOrigin,rayDirection,raycastParams); if not raycastResult or raycastResult.Instance:IsDescendantOf(char) then shortestDistance=distance; closestPlayer=player end end end end; return closestPlayer end
local function teleportBehindPlayer(targetPlayer) local localChar=LocalPlayer.Character; local localHRP=localChar and localChar:FindFirstChild("HumanoidRootPart"); local targetChar=targetPlayer.Character; local targetHRP=targetChar and targetChar:FindFirstChild("HumanoidRootPart"); if not localHRP or not targetHRP then return end; local targetPosition=targetHRP.Position; local targetLookVector=targetHRP.CFrame.LookVector; local behindPosition=targetPosition-(targetLookVector.Unit*TELEPORT_BEHIND_DISTANCE); local teleportPos=Vector3.new(behindPosition.X, localHRP.Position.Y, behindPosition.Z); local lookAtPos=Vector3.new(targetPosition.X, teleportPos.Y, targetPosition.Z); pcall(function() localHRP.CFrame=CFrame.new(teleportPos, lookAtPos) end) end
local function teleportRandomlyAroundPlayer(targetPlayer) local localChar=LocalPlayer.Character; local localHRP=localChar and localChar:FindFirstChild("HumanoidRootPart"); local targetChar=targetPlayer.Character; local targetHRP=targetChar and targetChar:FindFirstChild("HumanoidRootPart"); if not localHRP or not targetHRP then return end; local targetPosition=targetHRP.Position; local randomAngle=math.random()*2*math.pi; local randomRadius=math.random()*ANTI_AIM_RADIUS; local offsetX=math.cos(randomAngle)*randomRadius; local offsetZ=math.sin(randomAngle)*randomRadius; local randomPos=Vector3.new(targetPosition.X+offsetX, localHRP.Position.Y, targetPosition.Z+offsetZ); pcall(function() localHRP.CFrame = CFrame.new(randomPos) * (localHRP.CFrame - localHRP.CFrame.Position) end) end
local function createEspForPlayer(player) if espElements[player] then return end; local elements={}; elements.Box=Drawing.new("Quad"); elements.Box.Color=ESP_BOX_COLOR; elements.Box.Thickness=1; elements.Box.Filled=false; elements.Box.Visible=false; elements.Name=Drawing.new("Text"); elements.Name.Text=player.Name; elements.Name.Color=ESP_TEXT_COLOR; elements.Name.Size=ESP_TEXT_SIZE; elements.Name.Center=true; elements.Name.Outline=true; elements.Name.Visible=false; elements.Health=Drawing.new("Text"); elements.Health.Text="100/100"; elements.Health.Color=ESP_TEXT_COLOR; elements.Health.Size=ESP_HEALTH_SIZE; elements.Health.Center=true; elements.Health.Outline=true; elements.Health.Visible=false; espElements[player]=elements; end
local function removeEspForPlayer(player) if espElements[player] then local elements=espElements[player]; if elements.Box then elements.Box:Remove() end; if elements.Name then elements.Name:Remove() end; if elements.Health then elements.Health:Remove() end; espElements[player]=nil end end
local function setFlightPhysics(enabled) local localChar = LocalPlayer.Character; local hrp = localChar and localChar:FindFirstChild("HumanoidRootPart"); if not hrp then return end; if enabled then print("DEBUG: Enabling flight physics."); if not bodyGyro then bodyGyro = Instance.new("BodyGyro"); bodyGyro.P = 5000; bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9); bodyGyro.CFrame = hrp.CFrame; bodyGyro.Parent = hrp; end; if not bodyVelocity then bodyVelocity = Instance.new("BodyVelocity"); bodyVelocity.P = 1250; bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9); bodyVelocity.Velocity = Vector3.new(0, 0, 0); bodyVelocity.Parent = hrp; end else print("DEBUG: Disabling flight physics."); if bodyGyro then bodyGyro:Destroy(); bodyGyro = nil; end; if bodyVelocity then bodyVelocity:Destroy(); bodyVelocity = nil; end end end
print("DEBUG: Core logic functions defined.")

-- Main Update Loop (RenderStepped)
-- (No changes needed here)
local rsConn
rsConn = RunService.RenderStepped:Connect(function() local success, err = pcall(function() local localChar = LocalPlayer.Character; local hrp = localChar and localChar:FindFirstChild("HumanoidRootPart"); if not hrp then return end; local isAiming = false; if currentAimbotHoldKey then if currentAimbotHoldKey:IsA("UserInputType") then isAiming=UserInputService:IsMouseButtonPressed(currentAimbotHoldKey) elseif currentAimbotHoldKey:IsA("KeyCode") then isAiming=UserInputService:IsKeyDown(currentAimbotHoldKey) end end; local aimbotTargetPlayer = nil; if aimbotEnabled and isAiming then aimbotTargetPlayer = getNearestPlayer() end; local isLocked = aimbotTargetPlayer ~= nil; if isLocked then local targetHead = aimbotTargetPlayer.Character and aimbotTargetPlayer.Character:FindFirstChild("Head"); if targetHead then Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetHead.Position) else isLocked = false end end; cueDot.BackgroundColor3 = isLocked and DOT_COLOR_LOCKED or DOT_COLOR_NOLOCK; local nearestMovementTarget = nil; if teleportModeActive or antiAimActive then nearestMovementTarget = getNearestPlayer() end; if flightActive then local moveVector = Vector3.new(0,0,0); if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVector=moveVector+Vector3.new(0,0,-1) end; if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVector=moveVector+Vector3.new(0,0,1) end; if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVector=moveVector+Vector3.new(-1,0,0) end; if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVector=moveVector+Vector3.new(1,0,0) end; local verticalVelocity=0; if UserInputService:IsKeyDown(Enum.KeyCode.Space) then verticalVelocity=FLIGHT_VERTICAL_SPEED end; if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then verticalVelocity=-FLIGHT_VERTICAL_SPEED end; local worldVelocity=(Camera.CFrame*CFrame.new(moveVector)).Position-Camera.CFrame.Position; worldVelocity=Vector3.new(worldVelocity.X,0,worldVelocity.Z).Unit*FLIGHT_SPEED+Vector3.new(0,verticalVelocity,0); if bodyVelocity then bodyVelocity.Velocity=worldVelocity end; if bodyGyro then bodyGyro.CFrame=Camera.CFrame end; elseif antiAimActive and nearestMovementTarget then teleportRandomlyAroundPlayer(nearestMovementTarget); elseif teleportModeActive and nearestMovementTarget then teleportBehindPlayer(nearestMovementTarget) end; if espEnabled then for _, player in pairs(Players:GetPlayers()) do if player==LocalPlayer then continue end; local char=player.Character; local hum=char and char:FindFirstChildOfClass("Humanoid"); local hrp=char and char:FindFirstChild("HumanoidRootPart"); local head=char and char:FindFirstChild("Head"); if hum and hrp and head and hum.Health>0 then if not espElements[player] then createEspForPlayer(player) end; local elements=espElements[player]; if not elements then continue end; local headPos,headVisible=Camera:WorldToViewportPoint(head.Position+Vector3.new(0,0.5,0)); local hrpPos,hrpVisible=Camera:WorldToViewportPoint(hrp.Position); if headVisible and hrpVisible then local boxHeight=math.abs(headPos.Y-hrpPos.Y); local boxWidth=boxHeight/2; local topLeft=Vector2.new(headPos.X-boxWidth/2,headPos.Y); local bottomRight=Vector2.new(hrpPos.X+boxWidth/2,hrpPos.Y); elements.Box.PointA=topLeft; elements.Box.PointB=Vector2.new(topLeft.X+boxWidth,topLeft.Y); elements.Box.PointC=Vector2.new(bottomRight.X,bottomRight.Y); elements.Box.PointD=Vector2.new(bottomRight.X-boxWidth,bottomRight.Y); elements.Box.Visible=true; elements.Name.Position=Vector2.new(headPos.X,headPos.Y-ESP_TEXT_SIZE-2); elements.Name.Visible=true; local healthText=math.floor(hum.Health).."/"..math.floor(hum.MaxHealth); elements.Health.Text=healthText; elements.Health.Position=Vector2.new(hrpPos.X,bottomRight.Y+2); elements.Health.Visible=true else elements.Box.Visible=false; elements.Name.Visible=false; elements.Health.Visible=false end else if espElements[player] then local elements=espElements[player]; elements.Box.Visible=false; elements.Name.Visible=false; elements.Health.Visible=false end end end; else for player,elements in pairs(espElements) do if elements.Box then elements.Box.Visible=false end; if elements.Name then elements.Name.Visible=false end; if elements.Health then elements.Health.Visible=false end end end; end); if not success then warn("DEBUG: ERROR in RenderStepped:", err); if rsConn then rsConn:Disconnect(); rsConn=nil; warn("DEBUG: Disconnected RenderStepped due to error.") end end end)
print("DEBUG: RenderStepped connected.")

-- ========== Player Added/Removed Handlers ==========
-- (No changes needed here)
print("DEBUG: Connecting Player Handlers...")
Players.PlayerAdded:Connect(createEspForPlayer)
Players.PlayerRemoving:Connect(removeEspForPlayer)
for _, player in pairs(Players:GetPlayers()) do if player ~= LocalPlayer then createEspForPlayer(player) end end
print("DEBUG: Initial players processed for ESP.")

-- ========== Input Handling ==========
-- (No changes needed here)
print("DEBUG: Connecting Input Handling...")
local inputConn
inputConn = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent) local success, err = pcall(function() if currentlyBindingKey=="aim" then print("DEBUG: Handling Keybind Input..."); if input.KeyCode==CANCEL_BIND_KEY then print("DEBUG: Keybind Cancelled."); resetButtonStates(); updateKeybindDisplay(); return end; if input.UserInputType==Enum.UserInputType.Keyboard then if input.KeyCode==Enum.KeyCode.LeftShift or input.KeyCode==Enum.KeyCode.RightShift or input.KeyCode==Enum.KeyCode.LeftControl or input.KeyCode==Enum.KeyCode.RightControl or input.KeyCode==Enum.KeyCode.LeftAlt or input.KeyCode==Enum.KeyCode.RightAlt or input.KeyCode==Enum.KeyCode.LeftSuper or input.KeyCode==Enum.KeyCode.RightSuper or input.KeyCode==Enum.KeyCode.CapsLock or input.KeyCode==Enum.KeyCode.Tab or input.KeyCode==TOGGLE_GUI_KEY or input.KeyCode==CANCEL_BIND_KEY or input.KeyCode==TELEPORT_KEY or input.KeyCode==ANTI_AIM_KEY or input.KeyCode==FLIGHT_TOGGLE_KEY then print("DEBUG: Ignored System/Control Key."); return end end; local newKey; if input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.MouseButton2 or input.UserInputType==Enum.UserInputType.MouseButton3 then newKey=input.UserInputType elseif input.UserInputType==Enum.UserInputType.Keyboard then newKey=input.KeyCode else print("DEBUG: Binding failed - Unsupported type:", input.UserInputType.Name); resetButtonStates(); updateKeybindDisplay(); return end; print("DEBUG: New Key Bound:", getKeyName(newKey)); currentAimbotHoldKey=newKey; resetButtonStates(); updateKeybindDisplay(); return end; if gameProcessedEvent then return end; if input.KeyCode==TOGGLE_GUI_KEY then print("DEBUG: Toggle GUI Key Pressed."); guiVisible=not guiVisible; mainFrame.Visible=guiVisible; if guiVisible then UserInputService.MouseBehavior=Enum.MouseBehavior.Default; UserInputService.MouseIconEnabled=true else UserInputService.MouseBehavior=Enum.MouseBehavior.Default; UserInputService.MouseIconEnabled=false end; return end; if input.KeyCode == TELEPORT_KEY then teleportModeActive = not teleportModeActive; if teleportModeActive then antiAimActive=false; setFlightPhysics(false); flightActive=false; print("DEBUG: Anti-Aim & Flight disabled.") end; print("DEBUG: Continuous Teleport Mode:", teleportModeActive and "ENABLED" or "DISABLED"); local soundId="rbxassetid://9111384194"; local pitch=teleportModeActive and 1 or 0.8; local volume=teleportModeActive and 0.5 or 0.3; game:GetService("SoundService"):PlayLocalSound(Instance.new("Sound",nil,{SoundId=soundId,Volume=volume,Pitch=pitch})); return end; if input.KeyCode == ANTI_AIM_KEY then antiAimActive = not antiAimActive; if antiAimActive then teleportModeActive=false; setFlightPhysics(false); flightActive=false; print("DEBUG: Teleport & Flight disabled.") end; print("DEBUG: Anti-Aim Jitter Mode:", antiAimActive and "ENABLED" or "DISABLED"); local soundId="rbxassetid://9111384194"; local pitch=antiAimActive and 1.2 or 0.7; local volume=antiAimActive and 0.6 or 0.4; game:GetService("SoundService"):PlayLocalSound(Instance.new("Sound",nil,{SoundId=soundId,Volume=volume,Pitch=pitch})); return end; if input.KeyCode == FLIGHT_TOGGLE_KEY then flightActive = not flightActive; setFlightPhysics(flightActive); if flightActive then teleportModeActive=false; antiAimActive=false; print("DEBUG: Teleport & Anti-Aim disabled.") end; print("DEBUG: Flight Mode:", flightActive and "ENABLED" or "DISABLED"); local soundId="rbxassetid://9111384194"; local pitch=flightActive and 1.4 or 0.6; local volume=flightActive and 0.6 or 0.4; game:GetService("SoundService"):PlayLocalSound(Instance.new("Sound", nil, {SoundId = soundId, Volume = volume, Pitch = pitch})); return end; end); if not success then warn("DEBUG: ERROR in InputBegan:", err); if inputConn then inputConn:Disconnect(); inputConn=nil; warn("DEBUG: Disconnected InputBegan due to error.") end end end)
print("DEBUG: Input Handling connected.")

-- ========== Initialization ==========
-- **** MODIFICATION 2: Set initial mouse state based on default GUI visibility ****
if guiVisible then
    print("DEBUG: Setting initial mouse state for visible GUI.")
    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    UserInputService.MouseIconEnabled = true
end

-- Cleanup function
-- (No changes needed here)
local function cleanup() print("DEBUG: Script cleanup initiated..."); if rsConn then rsConn:Disconnect(); rsConn=nil end; if aimCbConn then aimCbConn:Disconnect(); aimCbConn=nil end; if espCbConn then espCbConn:Disconnect(); espCbConn=nil end; if btnConn then btnConn:Disconnect(); btnConn=nil end; if inputConn then inputConn:Disconnect(); inputConn=nil end; setFlightPhysics(false); for player, _ in pairs(espElements) do removeEspForPlayer(player) end; if controlPanelGui and controlPanelGui.Parent then controlPanelGui:Destroy() end; if cueGui and cueGui.Parent then cueGui:Destroy() end; print("DEBUG: Cleanup complete.") end
if script and typeof(script) == "Instance" then script.Destroying:Connect(cleanup) end
