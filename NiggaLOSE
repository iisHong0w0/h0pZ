"\nprint(\"DEBUG: Script execution started (v9.5 - GUI Default Open).\")\n\n-- ========== Roblox Services ==========\nlocal Players = game:GetService(\"Players\")\nlocal RunService = game:GetService(\"RunService\")\nlocal UserInputService = game:GetService(\"UserInputService\")\nlocal Workspace = game:GetService(\"Workspace\")\nlocal CoreGui = game:GetService(\"CoreGui\")\nprint(\"DEBUG: Services loaded.\")\n\n-- ========== Player & Camera ==========\nlocal LocalPlayer = Players.LocalPlayer\nif not LocalPlayer then warn(\"DEBUG: FATAL - LocalPlayer not found!\") return end\nprint(\"DEBUG: LocalPlayer found:\", LocalPlayer.Name)\nlocal PlayerGui = LocalPlayer:WaitForChild(\"PlayerGui\")\nif not PlayerGui then warn(\"DEBUG: FATAL - PlayerGui not found after wait!\") return end\nprint(\"DEBUG: PlayerGui loaded.\")\nlocal Camera = Workspace.CurrentCamera\nif not Camera then warn(\"DEBUG: FATAL - Workspace.CurrentCamera not found!\") return end\nprint(\"DEBUG: Camera found.\")\n\n-- ========== Configuration ==========\nlocal DEFAULT_AIMBOT_HOLD_KEY = Enum.UserInputType.MouseButton2\nlocal TOGGLE_GUI_KEY = Enum.KeyCode.Insert\nlocal CANCEL_BIND_KEY = Enum.KeyCode.Escape\nlocal TELEPORT_KEY = Enum.KeyCode.H          -- 切換 持續傳送\nlocal ANTI_AIM_KEY = Enum.KeyCode.N          -- 切換 反瞄準抖動\nlocal FLIGHT_TOGGLE_KEY = Enum.KeyCode.V     -- 切換 飛行模式\nlocal TELEPORT_BEHIND_DISTANCE = 3\nlocal ANTI_AIM_RADIUS = 5\nlocal FLIGHT_SPEED = 50                      -- 水平飛行速度\nlocal FLIGHT_VERTICAL_SPEED = 30             -- 垂直飛行速度\n\n-- Visual Cue Dot / ESP Config\nlocal DOT_COLOR_NOLOCK=Color3.fromRGB(255,255,255); local DOT_COLOR_LOCKED=Color3.fromRGB(255,0,0); local DOT_SIZE=Vector2.new(4,4)\nlocal ESP_BOX_COLOR=Color3.fromRGB(0,150,255); local ESP_TEXT_COLOR=Color3.fromRGB(255,255,255); local ESP_TEXT_SIZE=14; local ESP_HEALTH_SIZE=12\nprint(\"DEBUG: Configuration set.\")\n\n-- ========== State Variables ==========\nlocal aimbotEnabled = true\nlocal espEnabled = true\nlocal teleportModeActive = false\nlocal antiAimActive = false\nlocal flightActive = false\nlocal guiVisible = true -- **** MODIFICATION 1: Set GUI to visible by default ****\nlocal currentAimbotHoldKey = DEFAULT_AIMBOT_HOLD_KEY\nlocal currentlyBindingKey = nil\nlocal espElements = {}\n-- Body Mover References\nlocal bodyVelocity = nil\nlocal bodyGyro = nil\nprint(\"DEBUG: State variables initialized (guiVisible=true).\")\n\n-- ========== GUI Creation (Control Panel - 中文) ==========\nprint(\"DEBUG: Creating Control Panel GUI...\")\nlocal controlPanelGui=Instance.new(\"ScreenGui\"); controlPanelGui.Name=\"AimbotESPControlPanel\"; controlPanelGui.ResetOnSpawn=false; controlPanelGui.ZIndexBehavior=Enum.ZIndexBehavior.Sibling; controlPanelGui.Parent=PlayerGui\nlocal mainFrame=Instance.new(\"Frame\"); mainFrame.Name=\"MainFrame\"; mainFrame.Size=UDim2.new(0,300,0,265); mainFrame.Position=UDim2.new(0,10,0,10); mainFrame.BackgroundColor3=Color3.fromRGB(40,40,40); mainFrame.BorderColor3=Color3.fromRGB(80,80,80); mainFrame.BorderSizePixel=2; mainFrame.Active=true; mainFrame.Draggable=true;\nmainFrame.Visible=guiVisible; -- This line now makes the frame visible initially because guiVisible is true\nmainFrame.Parent=controlPanelGui\n-- (Rest of GUI elements remain the same as your provided code)\nlocal titleLabel=Instance.new(\"TextLabel\"); titleLabel.Name=\"Title\"; titleLabel.Parent=mainFrame; titleLabel.Text=\"niggaLOSE\"; titleLabel.Size=UDim2.new(1,0,0,30); titleLabel.BackgroundColor3=Color3.fromRGB(50,50,50); titleLabel.TextColor3=Color3.fromRGB(255,255,255); titleLabel.Font=Enum.Font.SourceSansBold; titleLabel.TextSize=18; titleLabel.TextXAlignment=Enum.TextXAlignment.Center\nlocal enableAimbotCheckbox=Instance.new(\"TextButton\"); enableAimbotCheckbox.Name=\"EnableAimbotCheckbox\"; enableAimbotCheckbox.Parent=mainFrame; enableAimbotCheckbox.Size=UDim2.new(1,-20,0,25); enableAimbotCheckbox.Position=UDim2.new(0,10,0,40); enableAimbotCheckbox.BackgroundColor3=Color3.fromRGB(60,60,60); enableAimbotCheckbox.BorderSizePixel=1; enableAimbotCheckbox.Font=Enum.Font.SourceSans; enableAimbotCheckbox.TextSize=16\nlocal enableEspCheckbox=Instance.new(\"TextButton\"); enableEspCheckbox.Name=\"EnableEspCheckbox\"; enableEspCheckbox.Parent=mainFrame; enableEspCheckbox.Size=UDim2.new(1,-20,0,25); enableEspCheckbox.Position=UDim2.new(0,10,0,70); enableEspCheckbox.BackgroundColor3=Color3.fromRGB(60,60,60); enableEspCheckbox.BorderSizePixel=1; enableEspCheckbox.Font=Enum.Font.SourceSans; enableEspCheckbox.TextSize=16\nlocal aimKeyLabel=Instance.new(\"TextLabel\"); aimKeyLabel.Name=\"AimKeyLabel\"; aimKeyLabel.Parent=mainFrame; aimKeyLabel.Size=UDim2.new(0.6,-15,0,25); aimKeyLabel.Position=UDim2.new(0,10,0,105); aimKeyLabel.BackgroundTransparency=1; aimKeyLabel.TextColor3=Color3.fromRGB(180,180,180); aimKeyLabel.Font=Enum.Font.SourceSans; aimKeyLabel.TextSize=14; aimKeyLabel.TextXAlignment=Enum.TextXAlignment.Left\nlocal changeAimKeyButton=Instance.new(\"TextButton\"); changeAimKeyButton.Name=\"ChangeAimKey\"; changeAimKeyButton.Parent=mainFrame; changeAimKeyButton.Size=UDim2.new(0.4,-15,0,25); changeAimKeyButton.Position=UDim2.new(0.6,0,0,105); changeAimKeyButton.BackgroundColor3=Color3.fromRGB(70,70,100); changeAimKeyButton.BorderSizePixel=1; changeAimKeyButton.TextColor3=Color3.fromRGB(220,220,255); changeAimKeyButton.Font=Enum.Font.SourceSans; changeAimKeyButton.TextSize=14; changeAimKeyButton.Text=\"更改\"\nlocal teleportInfoLabel=Instance.new(\"TextLabel\"); teleportInfoLabel.Name=\"TeleportInfoLabel\"; teleportInfoLabel.Parent=mainFrame; teleportInfoLabel.Size=UDim2.new(1,-20,0,20); teleportInfoLabel.Position=UDim2.new(0,10,0,135); teleportInfoLabel.BackgroundTransparency=1; teleportInfoLabel.TextColor3=Color3.fromRGB(180,180,180); teleportInfoLabel.Font=Enum.Font.SourceSans; teleportInfoLabel.TextSize=14; teleportInfoLabel.TextXAlignment=Enum.TextXAlignment.Left; teleportInfoLabel.Text = \"按 H 切換持續傳送到敵人背後 (反武士刀)\"\nlocal antiAimInfoLabel=Instance.new(\"TextLabel\"); antiAimInfoLabel.Name=\"AntiAimInfoLabel\"; antiAimInfoLabel.Parent=mainFrame; antiAimInfoLabel.Size=UDim2.new(1,-20,0,20); antiAimInfoLabel.Position=UDim2.new(0,10,0,155); antiAimInfoLabel.BackgroundTransparency=1; antiAimInfoLabel.TextColor3=Color3.fromRGB(180,180,180); antiAimInfoLabel.Font=Enum.Font.SourceSans; antiAimInfoLabel.TextSize=14; antiAimInfoLabel.TextXAlignment=Enum.TextXAlignment.Left; antiAimInfoLabel.Text = \"按 N 切換反瞄準模式 (亂飛亂tp)\"\nlocal flightInfoLabel=Instance.new(\"TextLabel\"); flightInfoLabel.Name=\"FlightInfoLabel\"; flightInfoLabel.Parent=mainFrame; flightInfoLabel.Size=UDim2.new(1,-20,0,20); flightInfoLabel.Position=UDim2.new(0,10,0,175); flightInfoLabel.BackgroundTransparency=1; flightInfoLabel.TextColor3=Color3.fromRGB(180,180,180); flightInfoLabel.Font=Enum.Font.SourceSans; flightInfoLabel.TextSize=14; flightInfoLabel.TextXAlignment=Enum.TextXAlignment.Left; flightInfoLabel.Text = \"按 V 切換飛行模式 (WASD+空格/左Shift)\"\nlocal instructionLabel=Instance.new(\"TextLabel\"); instructionLabel.Name=\"InstructionLabel\"; instructionLabel.Parent=mainFrame; instructionLabel.Size=UDim2.new(1,-20,0,40); instructionLabel.Position=UDim2.new(0,10,0,200); instructionLabel.BackgroundTransparency=1; instructionLabel.TextColor3=Color3.fromRGB(150,150,150); instructionLabel.Font=Enum.Font.SourceSansItalic; instructionLabel.TextSize=12; instructionLabel.TextWrapped=true; instructionLabel.Text=\"需要自動打請打開外部必要.ahk。\\n中心點始終顯示。\\nIns切換面板, Esc取消綁定。\"\nprint(\"DEBUG: Control Panel GUI created.\")\n\n-- ========== GUI Creation (Visual Cue Dot) ==========\n-- (No changes needed here)\nprint(\"DEBUG: Creating Visual Cue GUI...\")\nlocal cueGui=Instance.new(\"ScreenGui\"); cueGui.Name=\"AimbotVisualCueGui\"; cueGui.ResetOnSpawn=false; cueGui.IgnoreGuiInset=true; cueGui.ZIndexBehavior=Enum.ZIndexBehavior.Global; cueGui.DisplayOrder=1000; cueGui.Parent=CoreGui\nlocal cueDot=Instance.new(\"Frame\"); cueDot.Name=\"CueDot\"; cueDot.Size=UDim2.fromOffset(DOT_SIZE.X,DOT_SIZE.Y); cueDot.AnchorPoint=Vector2.new(0.5,0.5); cueDot.Position=UDim2.new(0.5,0,0.5,0); cueDot.BackgroundColor3=DOT_COLOR_NOLOCK; cueDot.BorderSizePixel=0; cueDot.Visible=true; cueDot.Parent=cueGui\nlocal dotCorner=Instance.new(\"UICorner\"); dotCorner.CornerRadius=UDim.new(0.5,0); dotCorner.Parent=cueDot\nprint(\"DEBUG: Visual Cue GUI created.\")\n\n-- ========== Helper Functions ==========\n-- (No changes needed here)\nprint(\"DEBUG: Defining Helper Functions...\")\nlocal function getKeyName(inputObject) if not inputObject then return \"NONE\" end local success, name = pcall(function() if inputObject:IsA(\"KeyCode\") then return inputObject.Name elseif inputObject:IsA(\"UserInputType\") then if inputObject==Enum.UserInputType.MouseButton1 then return \"MOUSE1\" elseif inputObject==Enum.UserInputType.MouseButton2 then return \"MOUSE2\" elseif inputObject==Enum.UserInputType.MouseButton3 then return \"MOUSE3\" else return inputObject.Name end end return \"UNKNOWN\" end) return success and name or \"ERROR\" end\nlocal function updateCheckboxText() local success = pcall(function() if aimbotEnabled then enableAimbotCheckbox.Text = \"啟用 自動瞄準: [ ON ]\"; enableAimbotCheckbox.TextColor3 = Color3.fromRGB(0, 255, 0) else enableAimbotCheckbox.Text = \"啟用 自動瞄準: [ OFF ]\"; enableAimbotCheckbox.TextColor3 = Color3.fromRGB(255, 0, 0) end; if espEnabled then enableEspCheckbox.Text = \"啟用 ESP透視: [ ON ]\"; enableEspCheckbox.TextColor3 = Color3.fromRGB(0, 255, 0) else enableEspCheckbox.Text = \"啟用 ESP透視: [ OFF ]\"; enableEspCheckbox.TextColor3 = Color3.fromRGB(255, 0, 0) end end) if not success then warn(\"Error updating checkbox text\") end end\nlocal function updateKeybindDisplay() local success = pcall(function() aimKeyLabel.Text = \"瞄準鍵: \" .. getKeyName(currentAimbotHoldKey) end) if not success then warn(\"Error updating keybind display\") end end\nlocal function resetButtonStates() local success = pcall(function() changeAimKeyButton.Text = \"更改\"; changeAimKeyButton.BackgroundColor3 = Color3.fromRGB(70, 70, 100); currentlyBindingKey = nil end) if not success then warn(\"Error resetting button states\") end end\npcall(updateCheckboxText); pcall(updateKeybindDisplay)\nprint(\"DEBUG: Helper Functions defined.\")\n\n-- ========== GUI Event Handlers ==========\n-- (No changes needed here)\nprint(\"DEBUG: Connecting GUI Event Handlers...\")\nlocal aimCbConn, espCbConn, btnConn\naimCbConn = enableAimbotCheckbox.MouseButton1Click:Connect(function() local success = pcall(function() print(\"DEBUG: Aimbot Checkbox Clicked.\"); aimbotEnabled = not aimbotEnabled; updateCheckboxText(); end) if not success then warn(\"Error in aimbot checkbox click handler\") end end)\nespCbConn = enableEspCheckbox.MouseButton1Click:Connect(function() local success = pcall(function() print(\"DEBUG: ESP Checkbox Clicked.\"); espEnabled = not espEnabled; updateCheckboxText(); if not espEnabled then for _, elements in pairs(espElements) do if elements.Box then elements.Box.Visible = false end; if elements.Name then elements.Name.Visible = false end; if elements.Health then elements.Health.Visible = false end end end end) if not success then warn(\"Error in ESP checkbox click handler\") end end)\nbtnConn = changeAimKeyButton.MouseButton1Click:Connect(function() local success = pcall(function() print(\"DEBUG: Change Key Button Clicked.\"); if currentlyBindingKey then return end; currentlyBindingKey = \"aim\"; changeAimKeyButton.Text = \"按下按鍵...\"; changeAimKeyButton.BackgroundColor3 = Color3.fromRGB(100, 100, 70) end) if not success then warn(\"Error in change key button handler\") end end)\nprint(\"DEBUG: GUI Event Handlers connected.\")\n\n-- ========== Core Logic ==========\n-- (No changes needed in these functions)\nprint(\"DEBUG: Defining Core Logic Functions...\")\nlocal function getNearestPlayer() local closestPlayer=nil; local shortestDistance=math.huge; local localChar=LocalPlayer.Character; local localHRP=localChar and localChar:FindFirstChild(\"HumanoidRootPart\"); if not localChar or not localHRP then return nil end; for _, player in pairs(Players:GetPlayers()) do local char=player.Character; local hrp=char and char:FindFirstChild(\"HumanoidRootPart\"); local head=char and char:FindFirstChild(\"Head\"); local hum=char and char:FindFirstChildOfClass(\"Humanoid\"); if player~=LocalPlayer and hrp and head and hum and hum.Health>0 then local distance=(hrp.Position-localHRP.Position).Magnitude; if distance\u003CshortestDistance then local rayOrigin=Camera.CFrame.Position; local rayDirection=(head.Position-rayOrigin).Unit*distance; local raycastParams=RaycastParams.new(); raycastParams.FilterDescendantsInstances={localChar,Camera,controlPanelGui,cueGui}; raycastParams.FilterType=Enum.RaycastFilterType.Exclude; local raycastResult=Workspace:Raycast(rayOrigin,rayDirection,raycastParams); if not raycastResult or raycastResult.Instance:IsDescendantOf(char) then shortestDistance=distance; closestPlayer=player end end end end; return closestPlayer end\nlocal function teleportBehindPlayer(targetPlayer) local localChar=LocalPlayer.Character; local localHRP=localChar and localChar:FindFirstChild(\"HumanoidRootPart\"); local targetChar=targetPlayer.Character; local targetHRP=targetChar and targetChar:FindFirstChild(\"HumanoidRootPart\"); if not localHRP or not targetHRP then return end; local targetPosition=targetHRP.Position; local targetLookVector=targetHRP.CFrame.LookVector; local behindPosition=targetPosition-(targetLookVector.Unit*TELEPORT_BEHIND_DISTANCE); local teleportPos=Vector3.new(behindPosition.X, localHRP.Position.Y, behindPosition.Z); local lookAtPos=Vector3.new(targetPosition.X, teleportPos.Y, targetPosition.Z); pcall(function() localHRP.CFrame=CFrame.new(teleportPos, lookAtPos) end) end\nlocal function teleportRandomlyAroundPlayer(targetPlayer) local localChar=LocalPlayer.Character; local localHRP=localChar and localChar:FindFirstChild(\"HumanoidRootPart\"); local targetChar=targetPlayer.Character; local targetHRP=targetChar and targetChar:FindFirstChild(\"HumanoidRootPart\"); if not localHRP or not targetHRP then return end; local targetPosition=targetHRP.Position; local randomAngle=math.random()*2*math.pi; local randomRadius=math.random()*ANTI_AIM_RADIUS; local offsetX=math.cos(randomAngle)*randomRadius; local offsetZ=math.sin(randomAngle)*randomRadius; local randomPos=Vector3.new(targetPosition.X+offsetX, localHRP.Position.Y, targetPosition.Z+offsetZ); pcall(function() localHRP.CFrame = CFrame.new(randomPos) * (localHRP.CFrame - localHRP.CFrame.Position) end) end\nlocal function createEspForPlayer(player) if espElements[player] then return end; local elements={}; elements.Box=Drawing.new(\"Quad\"); elements.Box.Color=ESP_BOX_COLOR; elements.Box.Thickness=1; elements.Box.Filled=false; elements.Box.Visible=false; elements.Name=Drawing.new(\"Text\"); elements.Name.Text=player.Name; elements.Name.Color=ESP_TEXT_COLOR; elements.Name.Size=ESP_TEXT_SIZE; elements.Name.Center=true; elements.Name.Outline=true; elements.Name.Visible=false; elements.Health=Drawing.new(\"Text\"); elements.Health.Text=\"100/100\"; elements.Health.Color=ESP_TEXT_COLOR; elements.Health.Size=ESP_HEALTH_SIZE; elements.Health.Center=true; elements.Health.Outline=true; elements.Health.Visible=false; espElements[player]=elements; end\nlocal function removeEspForPlayer(player) if espElements[player] then local elements=espElements[player]; if elements.Box then elements.Box:Remove() end; if elements.Name then elements.Name:Remove() end; if elements.Health then elements.Health:Remove() end; espElements[player]=nil end end\nlocal function setFlightPhysics(enabled) local localChar = LocalPlayer.Character; local hrp = localChar and localChar:FindFirstChild(\"HumanoidRootPart\"); if not hrp then return end; if enabled then print(\"DEBUG: Enabling flight physics.\"); if not bodyGyro then bodyGyro = Instance.new(\"BodyGyro\"); bodyGyro.P = 5000; bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9); bodyGyro.CFrame = hrp.CFrame; bodyGyro.Parent = hrp; end; if not bodyVelocity then bodyVelocity = Instance.new(\"BodyVelocity\"); bodyVelocity.P = 1250; bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9); bodyVelocity.Velocity = Vector3.new(0, 0, 0); bodyVelocity.Parent = hrp; end else print(\"DEBUG: Disabling flight physics.\"); if bodyGyro then bodyGyro:Destroy(); bodyGyro = nil; end; if bodyVelocity then bodyVelocity:Destroy(); bodyVelocity = nil; end end end\nprint(\"DEBUG: Core logic functions defined.\")\n\n-- Main Update Loop (RenderStepped)\n-- (No changes needed here)\nlocal rsConn\nrsConn = RunService.RenderStepped:Connect(function() local success, err = pcall(function() local localChar = LocalPlayer.Character; local hrp = localChar and localChar:FindFirstChild(\"HumanoidRootPart\"); if not hrp then return end; local isAiming = false; if currentAimbotHoldKey then if currentAimbotHoldKey:IsA(\"UserInputType\") then isAiming=UserInputService:IsMouseButtonPressed(currentAimbotHoldKey) elseif currentAimbotHoldKey:IsA(\"KeyCode\") then isAiming=UserInputService:IsKeyDown(currentAimbotHoldKey) end end; local aimbotTargetPlayer = nil; if aimbotEnabled and isAiming then aimbotTargetPlayer = getNearestPlayer() end; local isLocked = aimbotTargetPlayer ~= nil; if isLocked then local targetHead = aimbotTargetPlayer.Character and aimbotTargetPlayer.Character:FindFirstChild(\"Head\"); if targetHead then Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetHead.Position) else isLocked = false end end; cueDot.BackgroundColor3 = isLocked and DOT_COLOR_LOCKED or DOT_COLOR_NOLOCK; local nearestMovementTarget = nil; if teleportModeActive or antiAimActive then nearestMovementTarget = getNearestPlayer() end; if flightActive then local moveVector = Vector3.new(0,0,0); if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVector=moveVector+Vector3.new(0,0,-1) end; if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVector=moveVector+Vector3.new(0,0,1) end; if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVector=moveVector+Vector3.new(-1,0,0) end; if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVector=moveVector+Vector3.new(1,0,0) end; local verticalVelocity=0; if UserInputService:IsKeyDown(Enum.KeyCode.Space) then verticalVelocity=FLIGHT_VERTICAL_SPEED end; if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then verticalVelocity=-FLIGHT_VERTICAL_SPEED end; local worldVelocity=(Camera.CFrame*CFrame.new(moveVector)).Position-Camera.CFrame.Position; worldVelocity=Vector3.new(worldVelocity.X,0,worldVelocity.Z).Unit*FLIGHT_SPEED+Vector3.new(0,verticalVelocity,0); if bodyVelocity then bodyVelocity.Velocity=worldVelocity end; if bodyGyro then bodyGyro.CFrame=Camera.CFrame end; elseif antiAimActive and nearestMovementTarget then teleportRandomlyAroundPlayer(nearestMovementTarget); elseif teleportModeActive and nearestMovementTarget then teleportBehindPlayer(nearestMovementTarget) end; if espEnabled then for _, player in pairs(Players:GetPlayers()) do if player==LocalPlayer then continue end; local char=player.Character; local hum=char and char:FindFirstChildOfClass(\"Humanoid\"); local hrp=char and char:FindFirstChild(\"HumanoidRootPart\"); local head=char and char:FindFirstChild(\"Head\"); if hum and hrp and head and hum.Health>0 then if not espElements[player] then createEspForPlayer(player) end; local elements=espElements[player]; if not elements then continue end; local headPos,headVisible=Camera:WorldToViewportPoint(head.Position+Vector3.new(0,0.5,0)); local hrpPos,hrpVisible=Camera:WorldToViewportPoint(hrp.Position); if headVisible and hrpVisible then local boxHeight=math.abs(headPos.Y-hrpPos.Y); local boxWidth=boxHeight/2; local topLeft=Vector2.new(headPos.X-boxWidth/2,headPos.Y); local bottomRight=Vector2.new(hrpPos.X+boxWidth/2,hrpPos.Y); elements.Box.PointA=topLeft; elements.Box.PointB=Vector2.new(topLeft.X+boxWidth,topLeft.Y); elements.Box.PointC=Vector2.new(bottomRight.X,bottomRight.Y); elements.Box.PointD=Vector2.new(bottomRight.X-boxWidth,bottomRight.Y); elements.Box.Visible=true; elements.Name.Position=Vector2.new(headPos.X,headPos.Y-ESP_TEXT_SIZE-2); elements.Name.Visible=true; local healthText=math.floor(hum.Health)..\"/\"..math.floor(hum.MaxHealth); elements.Health.Text=healthText; elements.Health.Position=Vector2.new(hrpPos.X,bottomRight.Y+2); elements.Health.Visible=true else elements.Box.Visible=false; elements.Name.Visible=false; elements.Health.Visible=false end else if espElements[player] then local elements=espElements[player]; elements.Box.Visible=false; elements.Name.Visible=false; elements.Health.Visible=false end end end; else for player,elements in pairs(espElements) do if elements.Box then elements.Box.Visible=false end; if elements.Name then elements.Name.Visible=false end; if elements.Health then elements.Health.Visible=false end end end; end); if not success then warn(\"DEBUG: ERROR in RenderStepped:\", err); if rsConn then rsConn:Disconnect(); rsConn=nil; warn(\"DEBUG: Disconnected RenderStepped due to error.\") end end end)\nprint(\"DEBUG: RenderStepped connected.\")\n\n-- ========== Player Added/Removed Handlers ==========\n-- (No changes needed here)\nprint(\"DEBUG: Connecting Player Handlers...\")\nPlayers.PlayerAdded:Connect(createEspForPlayer)\nPlayers.PlayerRemoving:Connect(removeEspForPlayer)\nfor _, player in pairs(Players:GetPlayers()) do if player ~= LocalPlayer then createEspForPlayer(player) end end\nprint(\"DEBUG: Initial players processed for ESP.\")\n\n-- ========== Input Handling ==========\n-- (No changes needed here)\nprint(\"DEBUG: Connecting Input Handling...\")\nlocal inputConn\ninputConn = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent) local success, err = pcall(function() if currentlyBindingKey==\"aim\" then print(\"DEBUG: Handling Keybind Input...\"); if input.KeyCode==CANCEL_BIND_KEY then print(\"DEBUG: Keybind Cancelled.\"); resetButtonStates(); updateKeybindDisplay(); return end; if input.UserInputType==Enum.UserInputType.Keyboard then if input.KeyCode==Enum.KeyCode.LeftShift or input.KeyCode==Enum.KeyCode.RightShift or input.KeyCode==Enum.KeyCode.LeftControl or input.KeyCode==Enum.KeyCode.RightControl or input.KeyCode==Enum.KeyCode.LeftAlt or input.KeyCode==Enum.KeyCode.RightAlt or input.KeyCode==Enum.KeyCode.LeftSuper or input.KeyCode==Enum.KeyCode.RightSuper or input.KeyCode==Enum.KeyCode.CapsLock or input.KeyCode==Enum.KeyCode.Tab or input.KeyCode==TOGGLE_GUI_KEY or input.KeyCode==CANCEL_BIND_KEY or input.KeyCode==TELEPORT_KEY or input.KeyCode==ANTI_AIM_KEY or input.KeyCode==FLIGHT_TOGGLE_KEY then print(\"DEBUG: Ignored System/Control Key.\"); return end end; local newKey; if input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.MouseButton2 or input.UserInputType==Enum.UserInputType.MouseButton3 then newKey=input.UserInputType elseif input.UserInputType==Enum.UserInputType.Keyboard then newKey=input.KeyCode else print(\"DEBUG: Binding failed - Unsupported type:\", input.UserInputType.Name); resetButtonStates(); updateKeybindDisplay(); return end; print(\"DEBUG: New Key Bound:\", getKeyName(newKey)); currentAimbotHoldKey=newKey; resetButtonStates(); updateKeybindDisplay(); return end; if gameProcessedEvent then return end; if input.KeyCode==TOGGLE_GUI_KEY then print(\"DEBUG: Toggle GUI Key Pressed.\"); guiVisible=not guiVisible; mainFrame.Visible=guiVisible; if guiVisible then UserInputService.MouseBehavior=Enum.MouseBehavior.Default; UserInputService.MouseIconEnabled=true else UserInputService.MouseBehavior=Enum.MouseBehavior.Default; UserInputService.MouseIconEnabled=false end; return end; if input.KeyCode == TELEPORT_KEY then teleportModeActive = not teleportModeActive; if teleportModeActive then antiAimActive=false; setFlightPhysics(false); flightActive=false; print(\"DEBUG: Anti-Aim & Flight disabled.\") end; print(\"DEBUG: Continuous Teleport Mode:\", teleportModeActive and \"ENABLED\" or \"DISABLED\"); local soundId=\"rbxassetid://9111384194\"; local pitch=teleportModeActive and 1 or 0.8; local volume=teleportModeActive and 0.5 or 0.3; game:GetService(\"SoundService\"):PlayLocalSound(Instance.new(\"Sound\",nil,{SoundId=soundId,Volume=volume,Pitch=pitch})); return end; if input.KeyCode == ANTI_AIM_KEY then antiAimActive = not antiAimActive; if antiAimActive then teleportModeActive=false; setFlightPhysics(false); flightActive=false; print(\"DEBUG: Teleport & Flight disabled.\") end; print(\"DEBUG: Anti-Aim Jitter Mode:\", antiAimActive and \"ENABLED\" or \"DISABLED\"); local soundId=\"rbxassetid://9111384194\"; local pitch=antiAimActive and 1.2 or 0.7; local volume=antiAimActive and 0.6 or 0.4; game:GetService(\"SoundService\"):PlayLocalSound(Instance.new(\"Sound\",nil,{SoundId=soundId,Volume=volume,Pitch=pitch})); return end; if input.KeyCode == FLIGHT_TOGGLE_KEY then flightActive = not flightActive; setFlightPhysics(flightActive); if flightActive then teleportModeActive=false; antiAimActive=false; print(\"DEBUG: Teleport & Anti-Aim disabled.\") end; print(\"DEBUG: Flight Mode:\", flightActive and \"ENABLED\" or \"DISABLED\"); local soundId=\"rbxassetid://9111384194\"; local pitch=flightActive and 1.4 or 0.6; local volume=flightActive and 0.6 or 0.4; game:GetService(\"SoundService\"):PlayLocalSound(Instance.new(\"Sound\", nil, {SoundId = soundId, Volume = volume, Pitch = pitch})); return end; end); if not success then warn(\"DEBUG: ERROR in InputBegan:\", err); if inputConn then inputConn:Disconnect(); inputConn=nil; warn(\"DEBUG: Disconnected InputBegan due to error.\") end end end)\nprint(\"DEBUG: Input Handling connected.\")\n\n-- ========== Initialization ==========\n-- **** MODIFICATION 2: Set initial mouse state based on default GUI visibility ****\nif guiVisible then\n    print(\"DEBUG: Setting initial mouse state for visible GUI.\")\n    UserInputService.MouseBehavior = Enum.MouseBehavior.Default\n    UserInputService.MouseIconEnabled = true\nend\n\n-- Cleanup function\n-- (No changes needed here)\nlocal function cleanup() print(\"DEBUG: Script cleanup initiated...\"); if rsConn then rsConn:Disconnect(); rsConn=nil end; if aimCbConn then aimCbConn:Disconnect(); aimCbConn=nil end; if espCbConn then espCbConn:Disconnect(); espCbConn=nil end; if btnConn then btnConn:Disconnect(); btnConn=nil end; if inputConn then inputConn:Disconnect(); inputConn=nil end; setFlightPhysics(false); for player, _ in pairs(espElements) do removeEspForPlayer(player) end; if controlPanelGui and controlPanelGui.Parent then controlPanelGui:Destroy() end; if cueGui and cueGui.Parent then cueGui:Destroy() end; print(\"DEBUG: Cleanup complete.\") end\nif script and typeof(script) == \"Instance\" then script.Destroying:Connect(cleanup) end"