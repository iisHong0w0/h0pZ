-- 看三小 -
-- ========== Roblox Services ==========
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
print("DEBUG: Services loaded.")

-- ========== Player & Camera ==========
local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then warn("DEBUG: FATAL - LocalPlayer not found!") return end
print("DEBUG: LocalPlayer found:", LocalPlayer.Name)
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
if not PlayerGui then warn("DEBUG: FATAL - PlayerGui not found after wait!") return end
print("DEBUG: PlayerGui loaded.")
local Camera = Workspace.CurrentCamera
if not Camera then warn("DEBUG: FATAL - Workspace.CurrentCamera not found!") return end
print("DEBUG: Camera found.")

-- ========== Configuration ==========
-- Aimbot/ESP/Base Features Config
local DEFAULT_AIMBOT_HOLD_KEY = Enum.UserInputType.MouseButton2
local TOGGLE_GUI_KEY = Enum.KeyCode.Insert
local CANCEL_BIND_KEY = Enum.KeyCode.Escape
local TELEPORT_KEY = Enum.KeyCode.H          -- 切換 持續傳送
local ANTI_AIM_KEY = Enum.KeyCode.N          -- 切換 反瞄準抖動 (來自原腳本)
local FLIGHT_TOGGLE_KEY = Enum.KeyCode.V     -- 切換 飛行模式
local TELEPORT_BEHIND_DISTANCE = 3
local ANTI_AIM_RADIUS = 5
local FLIGHT_SPEED = 50
local FLIGHT_VERTICAL_SPEED = 30
local TRIGGERBOT_CLICK_INTERVAL = 0       -- Adjusted interval

-- Visual Cue Dot / ESP Config
local DOT_COLOR_NOLOCK=Color3.fromRGB(255,255,255); local DOT_COLOR_LOCKED=Color3.fromRGB(255,0,0); local DOT_SIZE=Vector2.new(4,4)
local ESP_BOX_COLOR=Color3.fromRGB(0,150,255); local ESP_TEXT_COLOR=Color3.fromRGB(255,255,255); local ESP_TEXT_SIZE=14; local ESP_HEALTH_SIZE=12

-- Third Person Config (Merged)
local THIRD_PERSON_TOGGLE_KEY = Enum.KeyCode.T  -- 切換第三人稱的按鍵
local THIRD_PERSON_OFFSET = Vector3.new(1.5, 2, 8) -- 第三人稱攝像機相對 *攝像機方向* 的偏移量
local THIRD_PERSON_SMOOTHING = 0.1             -- 第三人稱相機移動的平滑度

print("DEBUG: Configuration set.")

-- ========== State Variables ==========
-- Base Features States
local aimbotEnabled = true
local espEnabled = true
local teleportModeActive = false
local antiAimActive = false -- Note: This is the random teleport anti-aim, not head jitter
local flightActive = false
local guiVisible = true
local currentAimbotHoldKey = DEFAULT_AIMBOT_HOLD_KEY
local currentlyBindingKey = nil
local espElements = {}
local lastShootingState = false
local lastClickTime = 0
-- Body Mover References
local bodyVelocity = nil
local bodyGyro = nil

-- Third Person States (Merged)
local thirdPersonActive = false
local originalCameraType = Camera.CameraType
local originalCameraFocus = Camera.Focus
local lastThirdPersonPos = nil -- Used for smoothing AND aim correction

print("DEBUG: State variables initialized.")

-- ========== GUI Creation (Control Panel - 中文) ==========
-- (GUI Code remains the same as original aimbot script)
print("DEBUG: Creating Control Panel GUI...")
local controlPanelGui=Instance.new("ScreenGui"); controlPanelGui.Name="AimbotESPControlPanel"; controlPanelGui.ResetOnSpawn=false; controlPanelGui.ZIndexBehavior=Enum.ZIndexBehavior.Sibling; controlPanelGui.Parent=PlayerGui
local mainFrame=Instance.new("Frame"); mainFrame.Name="MainFrame"; mainFrame.Size=UDim2.new(0,300,0,285); -- Increased size slightly for TP info
mainFrame.Position=UDim2.new(0,10,0,10); mainFrame.BackgroundColor3=Color3.fromRGB(40,40,40); mainFrame.BorderColor3=Color3.fromRGB(80,80,80); mainFrame.BorderSizePixel=2; mainFrame.Active=true; mainFrame.Draggable=true;
mainFrame.Visible=guiVisible; mainFrame.Parent=controlPanelGui
local titleLabel=Instance.new("TextLabel"); titleLabel.Name="Title"; titleLabel.Parent=mainFrame; titleLabel.Text="niggaLOSE+"; titleLabel.Size=UDim2.new(1,0,0,30); titleLabel.BackgroundColor3=Color3.fromRGB(50,50,50); titleLabel.TextColor3=Color3.fromRGB(255,255,255); titleLabel.Font=Enum.Font.SourceSansBold; titleLabel.TextSize=18; titleLabel.TextXAlignment=Enum.TextXAlignment.Center
local enableAimbotCheckbox=Instance.new("TextButton"); enableAimbotCheckbox.Name="EnableAimbotCheckbox"; enableAimbotCheckbox.Parent=mainFrame; enableAimbotCheckbox.Size=UDim2.new(1,-20,0,25); enableAimbotCheckbox.Position=UDim2.new(0,10,0,40); enableAimbotCheckbox.BackgroundColor3=Color3.fromRGB(60,60,60); enableAimbotCheckbox.BorderSizePixel=1; enableAimbotCheckbox.Font=Enum.Font.SourceSans; enableAimbotCheckbox.TextSize=16
local enableEspCheckbox=Instance.new("TextButton"); enableEspCheckbox.Name="EnableEspCheckbox"; enableEspCheckbox.Parent=mainFrame; enableEspCheckbox.Size=UDim2.new(1,-20,0,25); enableEspCheckbox.Position=UDim2.new(0,10,0,70); enableEspCheckbox.BackgroundColor3=Color3.fromRGB(60,60,60); enableEspCheckbox.BorderSizePixel=1; enableEspCheckbox.Font=Enum.Font.SourceSans; enableEspCheckbox.TextSize=16
local aimKeyLabel=Instance.new("TextLabel"); aimKeyLabel.Name="AimKeyLabel"; aimKeyLabel.Parent=mainFrame; aimKeyLabel.Size=UDim2.new(0.6,-15,0,25); aimKeyLabel.Position=UDim2.new(0,10,0,105); aimKeyLabel.BackgroundTransparency=1; aimKeyLabel.TextColor3=Color3.fromRGB(180,180,180); aimKeyLabel.Font=Enum.Font.SourceSans; aimKeyLabel.TextSize=14; aimKeyLabel.TextXAlignment=Enum.TextXAlignment.Left
local changeAimKeyButton=Instance.new("TextButton"); changeAimKeyButton.Name="ChangeAimKey"; changeAimKeyButton.Parent=mainFrame; changeAimKeyButton.Size=UDim2.new(0.4,-15,0,25); changeAimKeyButton.Position=UDim2.new(0.6,0,0,105); changeAimKeyButton.BackgroundColor3=Color3.fromRGB(70,70,100); changeAimKeyButton.BorderSizePixel=1; changeAimKeyButton.TextColor3=Color3.fromRGB(220,220,255); changeAimKeyButton.Font=Enum.Font.SourceSans; changeAimKeyButton.TextSize=14; changeAimKeyButton.Text="更改"
local teleportInfoLabel=Instance.new("TextLabel"); teleportInfoLabel.Name="TeleportInfoLabel"; teleportInfoLabel.Parent=mainFrame; teleportInfoLabel.Size=UDim2.new(1,-20,0,20); teleportInfoLabel.Position=UDim2.new(0,10,0,135); teleportInfoLabel.BackgroundTransparency=1; teleportInfoLabel.TextColor3=Color3.fromRGB(180,180,180); teleportInfoLabel.Font=Enum.Font.SourceSans; teleportInfoLabel.TextSize=14; teleportInfoLabel.TextXAlignment=Enum.TextXAlignment.Left; teleportInfoLabel.Text = "按 H 切換持續傳送到敵人背後"
local antiAimInfoLabel=Instance.new("TextLabel"); antiAimInfoLabel.Name="AntiAimInfoLabel"; antiAimInfoLabel.Parent=mainFrame; antiAimInfoLabel.Size=UDim2.new(1,-20,0,20); antiAimInfoLabel.Position=UDim2.new(0,10,0,155); antiAimInfoLabel.BackgroundTransparency=1; antiAimInfoLabel.TextColor3=Color3.fromRGB(180,180,180); antiAimInfoLabel.Font=Enum.Font.SourceSans; antiAimInfoLabel.TextSize=14; antiAimInfoLabel.TextXAlignment=Enum.TextXAlignment.Left; antiAimInfoLabel.Text = "按 N 切換隨機傳送 (Anti-Aim)"
local flightInfoLabel=Instance.new("TextLabel"); flightInfoLabel.Name="FlightInfoLabel"; flightInfoLabel.Parent=mainFrame; flightInfoLabel.Size=UDim2.new(1,-20,0,20); flightInfoLabel.Position=UDim2.new(0,10,0,175); flightInfoLabel.BackgroundTransparency=1; flightInfoLabel.TextColor3=Color3.fromRGB(180,180,180); flightInfoLabel.Font=Enum.Font.SourceSans; flightInfoLabel.TextSize=14; flightInfoLabel.TextXAlignment=Enum.TextXAlignment.Left; flightInfoLabel.Text = "按 V 切換飛行模式 (WASD+空格/Shift)"
local thirdPersonInfoLabel=Instance.new("TextLabel"); thirdPersonInfoLabel.Name="ThirdPersonInfoLabel"; thirdPersonInfoLabel.Parent=mainFrame; thirdPersonInfoLabel.Size=UDim2.new(1,-20,0,20); thirdPersonInfoLabel.Position=UDim2.new(0,10,0,195); thirdPersonInfoLabel.BackgroundTransparency=1; thirdPersonInfoLabel.TextColor3=Color3.fromRGB(180,180,180); thirdPersonInfoLabel.Font=Enum.Font.SourceSans; thirdPersonInfoLabel.TextSize=14; thirdPersonInfoLabel.TextXAlignment=Enum.TextXAlignment.Left; thirdPersonInfoLabel.Text = "按 T 切換第三人稱視角" -- Added TP Info
local instructionLabel=Instance.new("TextLabel"); instructionLabel.Name="InstructionLabel"; instructionLabel.Parent=mainFrame; instructionLabel.Size=UDim2.new(1,-20,0,40); instructionLabel.Position=UDim2.new(0,10,0,220); instructionLabel.BackgroundTransparency=1; instructionLabel.TextColor3=Color3.fromRGB(150,150,150); instructionLabel.Font=Enum.Font.SourceSansItalic; instructionLabel.TextSize=12; instructionLabel.TextWrapped=true; instructionLabel.Text="需要自動打請打開外部必要.ahk。 中心點始終顯示。 Ins切換面板, Esc取消綁定。"
print("DEBUG: Control Panel GUI created.")

-- ========== GUI Creation (Visual Cue Dot) ==========
-- (GUI Code remains the same)
print("DEBUG: Creating Visual Cue GUI...")
local cueGui=Instance.new("ScreenGui"); cueGui.Name="AimbotVisualCueGui"; cueGui.ResetOnSpawn=false; cueGui.IgnoreGuiInset=true; cueGui.ZIndexBehavior=Enum.ZIndexBehavior.Global; cueGui.DisplayOrder=1000; cueGui.Parent=CoreGui
local cueDot=Instance.new("Frame"); cueDot.Name="CueDot"; cueDot.Size=UDim2.fromOffset(DOT_SIZE.X,DOT_SIZE.Y); cueDot.AnchorPoint=Vector2.new(0.5,0.5); cueDot.Position=UDim2.new(0.5,0,0.5,0); cueDot.BackgroundColor3=DOT_COLOR_NOLOCK; cueDot.BorderSizePixel=0; cueDot.Visible=true; cueDot.Parent=cueGui
local dotCorner=Instance.new("UICorner"); dotCorner.CornerRadius=UDim.new(0.5,0); dotCorner.Parent=cueDot
print("DEBUG: Visual Cue GUI created.")

-- ========== Helper Functions ==========
-- (Original helper functions remain)
print("DEBUG: Defining Helper Functions...")
local function getKeyName(inputObject) if not inputObject then return "NONE" end local success, name = pcall(function() if inputObject:IsA("KeyCode") then return inputObject.Name elseif inputObject:IsA("UserInputType") then if inputObject==Enum.UserInputType.MouseButton1 then return "MOUSE1" elseif inputObject==Enum.UserInputType.MouseButton2 then return "MOUSE2" elseif inputObject==Enum.UserInputType.MouseButton3 then return "MOUSE3" else return inputObject.Name end end return "UNKNOWN" end) return success and name or "ERROR" end
local function updateCheckboxText() local success = pcall(function() if aimbotEnabled then enableAimbotCheckbox.Text = "啟用 自動瞄準: [ ON ]"; enableAimbotCheckbox.TextColor3 = Color3.fromRGB(0, 255, 0) else enableAimbotCheckbox.Text = "啟用 自動瞄準: [ OFF ]"; enableAimbotCheckbox.TextColor3 = Color3.fromRGB(255, 0, 0) end; if espEnabled then enableEspCheckbox.Text = "啟用 ESP透視: [ ON ]"; enableEspCheckbox.TextColor3 = Color3.fromRGB(0, 255, 0) else enableEspCheckbox.Text = "啟用 ESP透視: [ OFF ]"; enableEspCheckbox.TextColor3 = Color3.fromRGB(255, 0, 0) end end) if not success then warn("Error updating checkbox text") end end
local function updateKeybindDisplay() local success = pcall(function() aimKeyLabel.Text = "瞄準鍵: " .. getKeyName(currentAimbotHoldKey) end) if not success then warn("Error updating keybind display") end end
local function resetButtonStates() local success = pcall(function() changeAimKeyButton.Text = "更改"; changeAimKeyButton.BackgroundColor3 = Color3.fromRGB(70, 70, 100); currentlyBindingKey = nil end) if not success then warn("Error resetting button states") end end
pcall(updateCheckboxText); pcall(updateKeybindDisplay)
print("DEBUG: Helper Functions defined.")

-- ========== GUI Event Handlers ==========
-- (Original GUI handlers remain)
print("DEBUG: Connecting GUI Event Handlers...")
local aimCbConn, espCbConn, btnConn
aimCbConn = enableAimbotCheckbox.MouseButton1Click:Connect(function() local success = pcall(function() print("DEBUG: Aimbot Checkbox Clicked."); aimbotEnabled = not aimbotEnabled; updateCheckboxText(); end) if not success then warn("Error in aimbot checkbox click handler") end end)
espCbConn = enableEspCheckbox.MouseButton1Click:Connect(function() local success = pcall(function() print("DEBUG: ESP Checkbox Clicked."); espEnabled = not espEnabled; updateCheckboxText(); if not espEnabled then for _, elements in pairs(espElements) do if elements.Box then elements.Box.Visible = false end; if elements.Name then elements.Name.Visible = false end; if elements.Health then elements.Health.Visible = false end end end end) if not success then warn("Error in ESP checkbox click handler") end end)
btnConn = changeAimKeyButton.MouseButton1Click:Connect(function() local success = pcall(function() print("DEBUG: Change Key Button Clicked."); if currentlyBindingKey then return end; currentlyBindingKey = "aim"; changeAimKeyButton.Text = "按下按鍵..."; changeAimKeyButton.BackgroundColor3 = Color3.fromRGB(100, 100, 70) end) if not success then warn("Error in change key button handler") end end)
print("DEBUG: GUI Event Handlers connected.")

-- ========== Core Logic ==========
-- (Original core logic functions remain)
print("DEBUG: Defining Core Logic Functions...")
local function getNearestPlayer() local closestPlayer=nil; local shortestDistance=math.huge; local localChar=LocalPlayer.Character; local localHRP=localChar and localChar:FindFirstChild("HumanoidRootPart"); if not localChar or not localHRP then return nil end; for _, player in pairs(Players:GetPlayers()) do local char=player.Character; local hrp=char and char:FindFirstChild("HumanoidRootPart"); local head=char and char:FindFirstChild("Head"); local hum=char and char:FindFirstChildOfClass("Humanoid"); if player~=LocalPlayer and hrp and head and hum and hum.Health>0 then local distance=(hrp.Position-localHRP.Position).Magnitude; if distance<shortestDistance then local rayOrigin=Camera.CFrame.Position; local rayDirection=(head.Position-rayOrigin).Unit*distance; local raycastParams=RaycastParams.new(); raycastParams.FilterDescendantsInstances={localChar,Camera,controlPanelGui,cueGui}; raycastParams.FilterType=Enum.RaycastFilterType.Exclude; local raycastResult=Workspace:Raycast(rayOrigin,rayDirection,raycastParams); if not raycastResult or raycastResult.Instance:IsDescendantOf(char) then shortestDistance=distance; closestPlayer=player end end end end; return closestPlayer end
local function teleportBehindPlayer(targetPlayer) local localChar=LocalPlayer.Character; local localHRP=localChar and localChar:FindFirstChild("HumanoidRootPart"); local targetChar=targetPlayer.Character; local targetHRP=targetChar and targetChar:FindFirstChild("HumanoidRootPart"); if not localHRP or not targetHRP then return end; local targetPosition=targetHRP.Position; local targetLookVector=targetHRP.CFrame.LookVector; local behindPosition=targetPosition-(targetLookVector.Unit*TELEPORT_BEHIND_DISTANCE); local teleportPos=Vector3.new(behindPosition.X, localHRP.Position.Y, behindPosition.Z); local lookAtPos=Vector3.new(targetPosition.X, teleportPos.Y, targetPosition.Z); pcall(function() localHRP.CFrame=CFrame.new(teleportPos, lookAtPos) end) end
local function teleportRandomlyAroundPlayer(targetPlayer) local localChar=LocalPlayer.Character; local localHRP=localChar and localChar:FindFirstChild("HumanoidRootPart"); local targetChar=targetPlayer.Character; local targetHRP=targetChar and targetChar:FindFirstChild("HumanoidRootPart"); if not localHRP or not targetHRP then return end; local targetPosition=targetHRP.Position; local randomAngle=math.random()*2*math.pi; local randomRadius=math.random()*ANTI_AIM_RADIUS; local offsetX=math.cos(randomAngle)*randomRadius; local offsetZ=math.sin(randomAngle)*randomRadius; local randomPos=Vector3.new(targetPosition.X+offsetX, localHRP.Position.Y, targetPosition.Z+offsetZ); pcall(function() localHRP.CFrame = CFrame.new(randomPos) * (localHRP.CFrame - localHRP.CFrame.Position) end) end
local function createEspForPlayer(player) if espElements[player] then return end; local elements={}; elements.Box=Drawing.new("Quad"); elements.Box.Color=ESP_BOX_COLOR; elements.Box.Thickness=1; elements.Box.Filled=false; elements.Box.Visible=false; elements.Name=Drawing.new("Text"); elements.Name.Text=player.Name; elements.Name.Color=ESP_TEXT_COLOR; elements.Name.Size=ESP_TEXT_SIZE; elements.Name.Center=true; elements.Name.Outline=true; elements.Name.Visible=false; elements.Health=Drawing.new("Text"); elements.Health.Text="100/100"; elements.Health.Color=ESP_TEXT_COLOR; elements.Health.Size=ESP_HEALTH_SIZE; elements.Health.Center=true; elements.Health.Outline=true; elements.Health.Visible=false; espElements[player]=elements; end
local function removeEspForPlayer(player) if espElements[player] then local elements=espElements[player]; if elements.Box then elements.Box:Remove() end; if elements.Name then elements.Name:Remove() end; if elements.Health then elements.Health:Remove() end; espElements[player]=nil end end
local function setFlightPhysics(enabled) local localChar = LocalPlayer.Character; local hrp = localChar and localChar:FindFirstChild("HumanoidRootPart"); if not hrp then return end; if enabled then print("DEBUG: Enabling flight physics."); if not bodyGyro then bodyGyro = Instance.new("BodyGyro"); bodyGyro.P = 5000; bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9); bodyGyro.CFrame = hrp.CFrame; bodyGyro.Parent = hrp; end; if not bodyVelocity then bodyVelocity = Instance.new("BodyVelocity"); bodyVelocity.P = 1250; bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9); bodyVelocity.Velocity = Vector3.new(0, 0, 0); bodyVelocity.Parent = hrp; end else print("DEBUG: Disabling flight physics."); if bodyGyro then bodyGyro:Destroy(); bodyGyro = nil; end; if bodyVelocity then bodyVelocity:Destroy(); bodyVelocity = nil; end end end

-- Third Person Functions (Merged & Fixed)
local function updateThirdPerson()
    local character = LocalPlayer.Character
    local head = character and character:FindFirstChild("Head")
    local hrp = character and character:FindFirstChild("HumanoidRootPart")

    local anchorPart = head or hrp
    if not anchorPart then return end
    local anchorPos = anchorPart.Position

    local currentCamCF = Camera.CFrame
    local backwardOffset = -currentCamCF.LookVector * THIRD_PERSON_OFFSET.Z
    local rightOffset = currentCamCF.RightVector * THIRD_PERSON_OFFSET.X
    local upOffset = currentCamCF.UpVector * THIRD_PERSON_OFFSET.Y
    local desiredPos = anchorPos + backwardOffset + rightOffset + upOffset
    local lookAtPos = anchorPos

    local rayOrigin = anchorPos
    local rayDirection = desiredPos - rayOrigin
    local rayMagnitude = rayDirection.Magnitude
    if rayMagnitude < 0.1 then rayMagnitude = 0.1 end

    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    local raycastResult = Workspace:Raycast(rayOrigin, rayDirection.Unit * rayMagnitude, raycastParams)

    if raycastResult then
        desiredPos = raycastResult.Position - rayDirection.Unit * 0.5
    end

    if not lastThirdPersonPos then lastThirdPersonPos = desiredPos end
    local smoothedPos = lastThirdPersonPos:Lerp(desiredPos, 1 - THIRD_PERSON_SMOOTHING)
    lastThirdPersonPos = smoothedPos -- Update for next frame and for aimbot correction

    -- Don't set camera CFrame here if aimbot might override it
    -- Camera.CFrame = CFrame.new(smoothedPos, lookAtPos)
    -- Instead, just ensure camera type is correct. RenderStepped will handle CFrame.
    if Camera.CameraType ~= Enum.CameraType.Scriptable then
         Camera.CameraType = Enum.CameraType.Scriptable
    end
end

local function restoreCamera()
    Camera.CameraType = originalCameraType
    pcall(function() Camera.Focus = originalCameraFocus end) -- Wrap focus restore in pcall
    lastThirdPersonPos = nil
    print("DEBUG: Camera restored to default.")
end

print("DEBUG: Core logic functions defined.")


-- ====================================
-- Main Update Loop (RenderStepped)
-- ====================================
local rsConn
rsConn = RunService.RenderStepped:Connect(function()
    local success, err = pcall(function()
        local localChar = LocalPlayer.Character
        local hrp = localChar and localChar:FindFirstChild("HumanoidRootPart")
        local charHead = localChar and localChar:FindFirstChild("Head") -- Get character head for aiming ref
        if not hrp then return end

        local currentTime = tick()

        -- === Third Person Camera POSITIONING (Run first if active) ===
        if thirdPersonActive then
            updateThirdPerson() -- This now calculates smoothedPos and updates lastThirdPersonPos
        elseif Camera.CameraType == Enum.CameraType.Scriptable then
            -- If TP is off but camera is still scriptable, restore it
            warn("DEBUG: Camera was Scriptable while ThirdPerson was off. Restoring.")
            restoreCamera()
        end

        -- === Aimbot Target Finding ===
        local isAiming = false
        if currentAimbotHoldKey then
            if currentAimbotHoldKey:IsA("UserInputType") then isAiming = UserInputService:IsMouseButtonPressed(currentAimbotHoldKey)
            elseif currentAimbotHoldKey:IsA("KeyCode") then isAiming = UserInputService:IsKeyDown(currentAimbotHoldKey) end
        end

        local aimbotTargetPlayer = nil
        if aimbotEnabled and isAiming then
            aimbotTargetPlayer = getNearestPlayer()
        end

        -- === Aimbot Locking & Camera ORIENTATION ===
        local isLocked = false
        local newCameraCFrame = nil -- Store the calculated CFrame

        if aimbotTargetPlayer then
            local targetHead = aimbotTargetPlayer.Character and aimbotTargetPlayer.Character:FindFirstChild("Head")
            if targetHead then
                isLocked = true -- We have a target head

                if thirdPersonActive then
                    -- THIRD PERSON AIMING CORRECTION
                    if charHead and lastThirdPersonPos then -- Need char head and calculated TP pos
                        local aimDirection = (targetHead.Position - charHead.Position).Unit
                        -- Use the smoothed third-person position, but orient based on character's aim direction
                        newCameraCFrame = CFrame.new(lastThirdPersonPos, lastThirdPersonPos + aimDirection)
                    else
                        isLocked = false -- Can't perform TP aim correction
                        warn("DEBUG: TP Aim failed - Missing Character Head or lastThirdPersonPos")
                    end
                else
                    -- FIRST PERSON AIMING (Original)
                    newCameraCFrame = CFrame.new(Camera.CFrame.Position, targetHead.Position)
                end
            end -- End targetHead check
        end -- End aimbotTargetPlayer check

        -- === Apply Camera CFrame ===
        if isLocked and newCameraCFrame then
             -- Only set if aimbot is locked and calculated a CFrame
            local successCam = pcall(function() Camera.CFrame = newCameraCFrame end)
            if not successCam then warn("DEBUG: Failed to set Camera CFrame for aimbot") end
        elseif thirdPersonActive and lastThirdPersonPos then
             -- If not aiming, but TP is active, set the camera based on TP logic alone
             local lookAtPos = (charHead or hrp).Position
             local successCam = pcall(function() Camera.CFrame = CFrame.new(lastThirdPersonPos, lookAtPos) end)
             if not successCam then warn("DEBUG: Failed to set Camera CFrame for third person view") end
        end


        -- === Update Cue Dot ===
        cueDot.BackgroundColor3 = isLocked and DOT_COLOR_LOCKED or DOT_COLOR_NOLOCK

        -- === Triggerbot Logic ===
        local shouldBeShooting = isLocked -- Shoot only when aimbot is locked

        if shouldBeShooting then
            if currentTime - lastClickTime >= TRIGGERBOT_CLICK_INTERVAL then
                if typeof(mouse1press) == "function" then pcall(mouse1press)
                else warn("DEBUG: Triggerbot requires 'mouse1press' function!") end
                if typeof(mouse1release) == "function" then pcall(mouse1release)
                else warn("DEBUG: Triggerbot requires 'mouse1release' function!") end
                lastClickTime = currentTime
            end
        elseif lastShootingState then
             if typeof(mouse1release) == "function" then pcall(mouse1release) end
        end
        lastShootingState = shouldBeShooting

        -- === Other Features (Teleport, Anti-Aim TP, Flight) ===
        local nearestMovementTarget = nil
        if teleportModeActive or antiAimActive then nearestMovementTarget = getNearestPlayer() end

        if flightActive then
            local moveVector = Vector3.new(0,0,0); if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVector=moveVector+Vector3.new(0,0,-1) end; if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVector=moveVector+Vector3.new(0,0,1) end; if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVector=moveVector+Vector3.new(-1,0,0) end; if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVector=moveVector+Vector3.new(1,0,0) end; local verticalVelocity=0; if UserInputService:IsKeyDown(Enum.KeyCode.Space) then verticalVelocity=FLIGHT_VERTICAL_SPEED end; if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then verticalVelocity=-FLIGHT_VERTICAL_SPEED end; local worldVelocity=(Camera.CFrame*CFrame.new(moveVector)).Position-Camera.CFrame.Position; worldVelocity=Vector3.new(worldVelocity.X,0,worldVelocity.Z).Unit*FLIGHT_SPEED+Vector3.new(0,verticalVelocity,0); if bodyVelocity then bodyVelocity.Velocity=worldVelocity end; if bodyGyro then bodyGyro.CFrame=Camera.CFrame end
        elseif antiAimActive and nearestMovementTarget then teleportRandomlyAroundPlayer(nearestMovementTarget)
        elseif teleportModeActive and nearestMovementTarget then teleportBehindPlayer(nearestMovementTarget)
        end

        -- === ESP Logic ===
        if espEnabled then
             for _, player in pairs(Players:GetPlayers()) do if player==LocalPlayer then continue end; local char=player.Character; local hum=char and char:FindFirstChildOfClass("Humanoid"); local hrpEsp=char and char:FindFirstChild("HumanoidRootPart"); local headEsp=char and char:FindFirstChild("Head"); if hum and hrpEsp and headEsp and hum.Health>0 then if not espElements[player] then createEspForPlayer(player) end; local elements=espElements[player]; if not elements then continue end; local headPos,headVisible=Camera:WorldToViewportPoint(headEsp.Position+Vector3.new(0,0.5,0)); local hrpPos,hrpVisible=Camera:WorldToViewportPoint(hrpEsp.Position); if headVisible and hrpVisible then local boxHeight=math.abs(headPos.Y-hrpPos.Y); local boxWidth=boxHeight/2; local topLeft=Vector2.new(headPos.X-boxWidth/2,headPos.Y); local bottomRight=Vector2.new(hrpPos.X+boxWidth/2,hrpPos.Y); elements.Box.PointA=topLeft; elements.Box.PointB=Vector2.new(topLeft.X+boxWidth,topLeft.Y); elements.Box.PointC=Vector2.new(bottomRight.X,bottomRight.Y); elements.Box.PointD=Vector2.new(bottomRight.X-boxWidth,bottomRight.Y); elements.Box.Visible=true; elements.Name.Position=Vector2.new(headPos.X,headPos.Y-ESP_TEXT_SIZE-2); elements.Name.Visible=true; local healthText=math.floor(hum.Health).."/"..math.floor(hum.MaxHealth); elements.Health.Text=healthText; elements.Health.Position=Vector2.new(hrpPos.X,bottomRight.Y+2); elements.Health.Visible=true else elements.Box.Visible=false; elements.Name.Visible=false; elements.Health.Visible=false end else if espElements[player] then local elements=espElements[player]; elements.Box.Visible=false; elements.Name.Visible=false; elements.Health.Visible=false end end end
        else
            for player, elements in pairs(espElements) do if elements.Box then elements.Box.Visible = false end; if elements.Name then elements.Name.Visible = false end; if elements.Health then elements.Health.Visible = false end end
        end

    end)
    if not success then
        warn("DEBUG: ERROR in RenderStepped:", err)
        -- if rsConn then rsConn:Disconnect(); rsConn = nil; warn("DEBUG: Disconnected RenderStepped due to error.") end -- Optional: Uncomment to stop on error
    end
end)
print("DEBUG: RenderStepped connected.")

-- ========== Player Added/Removed Handlers ==========
print("DEBUG: Connecting Player Handlers...")
Players.PlayerAdded:Connect(createEspForPlayer)
Players.PlayerRemoving:Connect(removeEspForPlayer)
for _, player in pairs(Players:GetPlayers()) do if player ~= LocalPlayer then createEspForPlayer(player) end end
print("DEBUG: Initial players processed for ESP.")

-- ========== Input Handling ==========
print("DEBUG: Connecting Input Handling...")
local inputConn
inputConn = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if currentlyBindingKey == "aim" then
        print("DEBUG: Handling Keybind Input...")
        if input.KeyCode == CANCEL_BIND_KEY then
            print("DEBUG: Keybind Cancelled.")
            resetButtonStates(); updateKeybindDisplay(); return
        end
        if input.UserInputType == Enum.UserInputType.Keyboard then
            local k = input.KeyCode
            if k==Enum.KeyCode.LeftShift or k==Enum.KeyCode.RightShift or k==Enum.KeyCode.LeftControl or k==Enum.KeyCode.RightControl or k==Enum.KeyCode.LeftAlt or k==Enum.KeyCode.RightAlt or k==Enum.KeyCode.LeftSuper or k==Enum.KeyCode.RightSuper or k==Enum.KeyCode.CapsLock or k==Enum.KeyCode.Tab or k==TOGGLE_GUI_KEY or k==CANCEL_BIND_KEY or k==TELEPORT_KEY or k==ANTI_AIM_KEY or k==FLIGHT_TOGGLE_KEY or k==THIRD_PERSON_TOGGLE_KEY then -- Added TP key ignore
                print("DEBUG: Ignored System/Control Key for binding.")
                return
            end
        end
        local newKey
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.MouseButton2 or input.UserInputType == Enum.UserInputType.MouseButton3 then newKey = input.UserInputType
        elseif input.UserInputType == Enum.UserInputType.Keyboard then newKey = input.KeyCode
        else print("DEBUG: Binding failed - Unsupported type:", input.UserInputType.Name); resetButtonStates(); updateKeybindDisplay(); return end
        print("DEBUG: New Key Bound:", getKeyName(newKey))
        currentAimbotHoldKey = newKey; resetButtonStates(); updateKeybindDisplay()
        return
    end

    if gameProcessedEvent then return end -- Ignore if game processed (e.g., typing in chat)

    local success, err = pcall(function()
        -- GUI Toggle
        if input.KeyCode == TOGGLE_GUI_KEY then
            print("DEBUG: Toggle GUI Key Pressed.")
            guiVisible = not guiVisible; mainFrame.Visible = guiVisible
            UserInputService.MouseBehavior = Enum.MouseBehavior.Default -- Keep mouse free
            UserInputService.MouseIconEnabled = guiVisible -- Show/hide mouse icon with GUI
            return
        end

        -- Teleport Behind Toggle
        if input.KeyCode == TELEPORT_KEY then
            teleportModeActive = not teleportModeActive
            if teleportModeActive then antiAimActive=false; setFlightPhysics(false); flightActive=false; print("DEBUG: Anti-Aim & Flight disabled.") end
            print("DEBUG: Continuous Teleport Mode:", teleportModeActive and "ENABLED" or "DISABLED")
            local soundId="rbxassetid://9111384194"; local pitch=teleportModeActive and 1 or 0.8; local volume=teleportModeActive and 0.5 or 0.3
            game:GetService("SoundService"):PlayLocalSound(Instance.new("Sound",nil,{SoundId=soundId,Volume=volume,Pitch=pitch}))
            return
        end

        -- Anti-Aim (Random Teleport) Toggle
        if input.KeyCode == ANTI_AIM_KEY then
            antiAimActive = not antiAimActive
            if antiAimActive then teleportModeActive=false; setFlightPhysics(false); flightActive=false; print("DEBUG: Teleport & Flight disabled.") end
            print("DEBUG: Anti-Aim Jitter Mode:", antiAimActive and "ENABLED" or "DISABLED")
            local soundId="rbxassetid://9111384194"; local pitch=antiAimActive and 1.2 or 0.7; local volume=antiAimActive and 0.6 or 0.4
            game:GetService("SoundService"):PlayLocalSound(Instance.new("Sound",nil,{SoundId=soundId,Volume=volume,Pitch=pitch}))
            return
        end

        -- Flight Toggle
        if input.KeyCode == FLIGHT_TOGGLE_KEY then
            flightActive = not flightActive; setFlightPhysics(flightActive)
            if flightActive then teleportModeActive=false; antiAimActive=false; print("DEBUG: Teleport & Anti-Aim disabled.") end
            print("DEBUG: Flight Mode:", flightActive and "ENABLED" or "DISABLED")
            local soundId="rbxassetid://9111384194"; local pitch=flightActive and 1.4 or 0.6; local volume=flightActive and 0.6 or 0.4
            game:GetService("SoundService"):PlayLocalSound(Instance.new("Sound", nil, {SoundId = soundId, Volume = volume, Pitch = pitch}))
            return
        end

        -- Third Person Toggle (Merged)
        if input.KeyCode == THIRD_PERSON_TOGGLE_KEY then
            thirdPersonActive = not thirdPersonActive
            print("DEBUG: Third Person Toggled:", thirdPersonActive and "ON" or "OFF")
            if thirdPersonActive then
                 originalCameraType = Camera.CameraType
                 originalCameraFocus = Camera.Focus
                 print("DEBUG: Stored original camera type:", originalCameraType.Name)
                 Camera.CameraType = Enum.CameraType.Scriptable -- Set to scriptable immediately
                 lastThirdPersonPos = nil -- Reset smoothing start point
            else
                restoreCamera() -- Restore camera to previous state
            end
            return
        end

    end)
    if not success then
        warn("DEBUG: ERROR in InputBegan:", err)
        -- if inputConn then inputConn:Disconnect(); inputConn=nil; warn("DEBUG: Disconnected InputBegan due to error.") end -- Optional
    end
end)
print("DEBUG: Input Handling connected.")

-- ========== Initialization ==========
if guiVisible then
    print("DEBUG: Setting initial mouse state for visible GUI.")
    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    UserInputService.MouseIconEnabled = true
end

-- Cleanup function
local function cleanup()
    print("DEBUG: Script cleanup initiated...")
    if rsConn then rsConn:Disconnect(); rsConn=nil end
    if aimCbConn then aimCbConn:Disconnect(); aimCbConn=nil end
    if espCbConn then espCbConn:Disconnect(); espCbConn=nil end
    if btnConn then btnConn:Disconnect(); btnConn=nil end
    if inputConn then inputConn:Disconnect(); inputConn=nil end
    setFlightPhysics(false)
    for player, _ in pairs(espElements) do removeEspForPlayer(player) end
    if controlPanelGui and controlPanelGui.Parent then controlPanelGui:Destroy() end
    if cueGui and cueGui.Parent then cueGui:Destroy() end
    -- Restore camera if TP was active on cleanup
    if thirdPersonActive then
        pcall(restoreCamera)
    end
    print("DEBUG: Cleanup complete.")
end
if script and typeof(script) == "Instance" then script.Destroying:Connect(cleanup) end

print("--- Merged Aimbot/ESP/ThirdPerson Script Initialized (v3) ---")
print("--- Press Insert to toggle GUI ---")
