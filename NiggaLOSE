-- 看三小
-- ========== Roblox Services ==========
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
print("DEBUG: Services loaded.")

-- ========== Player & Camera ==========
local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then warn("DEBUG: FATAL - LocalPlayer not found!") return end
print("DEBUG: LocalPlayer found:", LocalPlayer.Name)
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
if not PlayerGui then warn("DEBUG: FATAL - PlayerGui not found after wait!") return end
print("DEBUG: PlayerGui loaded.")
local Camera = Workspace.CurrentCamera
if not Camera then warn("DEBUG: FATAL - Workspace.CurrentCamera not found!") return end
print("DEBUG: Camera found.")

-- ========== Initial Default Configuration (Keys will be managed by featuresConfig later) ==========
local DEFAULT_AIMBOT_HOLD_KEY_INIT = Enum.UserInputType.MouseButton2
local TOGGLE_GUI_KEY_INIT = Enum.KeyCode.Insert
local CANCEL_BIND_KEY = Enum.KeyCode.Escape -- This key is fixed for cancelling a bind
local TELEPORT_KEY_INIT = Enum.KeyCode.H
local ANTI_AIM_KEY_INIT = Enum.KeyCode.N
local FLIGHT_TOGGLE_KEY_INIT = Enum.KeyCode.V
local THIRD_PERSON_TOGGLE_KEY_INIT = Enum.KeyCode.T
local FAKE_LAG_TOGGLE_KEY_INIT = Enum.KeyCode.X

local TELEPORT_BEHIND_DISTANCE = 3
local ANTI_AIM_RADIUS = 5
local FLIGHT_SPEED = 50
local FLIGHT_VERTICAL_SPEED = 30
local TRIGGERBOT_CLICK_INTERVAL = 0

local DOT_COLOR_NOLOCK=Color3.fromRGB(255,255,255); local DOT_COLOR_LOCKED=Color3.fromRGB(255,0,0); local DOT_SIZE=Vector2.new(4,4)
local ESP_BOX_COLOR=Color3.fromRGB(0,150,255); local ESP_TEXT_COLOR=Color3.fromRGB(255,255,255); local ESP_TEXT_SIZE=14; local ESP_HEALTH_SIZE=12

local THIRD_PERSON_OFFSET = Vector3.new(1.5, 2, 8)
local THIRD_PERSON_SMOOTHING = 0.1

local GHOST_DELAY_SECONDS = 1
local GHOST_TRANSPARENCY = 0.5
local MIN_REAL_CFRAME_UPDATE_INTERVAL = 0.5
print("DEBUG: Initial default configurations set.")

-- ========== State Variables (Many will be managed by featuresConfig) ==========
local espElements = {}
local lastShootingState = false
local lastClickTime = 0
local bodyVelocity = nil
local bodyGyro = nil
local originalCameraType = Camera.CameraType
local originalCameraFocus = Camera.Focus
local lastThirdPersonPos = nil
local ghostModel = nil
local cframeHistory = {}
local lastRealCFrameAppliedTime = 0
local lastAppliedDelayedCFrame = nil
local currentlyBindingFeature = nil -- Stores the ID of the feature whose key is being bound

print("DEBUG: Core state variables initialized.")

-- Forward declaration for functions used in featuresConfig
local setFlightPhysics, destroyGhostModel, createOrUpdateGhostModel, restoreCamera, updateFeatureToggleButton, updateFeatureKeyDisplay

-- ========== Features Configuration & State Management Table ==========
local featuresConfig = {
    aimbot_module = {
        id = "aimbot_module",
        displayName = "自動瞄準模組",
        isEnabled = true, -- Initial state
        ui = {}, -- For toggle button
        -- This module's ON/OFF state is controlled by its GUI button. No separate hotkey.
    },
    esp_module = {
        id = "esp_module",
        displayName = "ESP透視模組",
        isEnabled = true, -- Initial state
        ui = {}, -- For toggle button
        onToggle = function(self, enabled)
            if not enabled then
                for _, elements in pairs(espElements) do
                    if elements.Box then elements.Box.Visible = false end
                    if elements.Name then elements.Name.Visible = false end
                    if elements.Health then elements.Health.Visible = false end
                end
            end
        end
    },
    aimbot_hold = { -- Special: This is for the AIMBOT HOLD KEY, not a toggle feature
        id = "aimbot_hold",
        displayName = "按住瞄準鍵",
        currentKey = DEFAULT_AIMBOT_HOLD_KEY_INIT, -- Will be UserInputType or KeyCode
        ui = {}, -- For key display and change button
    },
    teleport_mode = {
        id = "teleport_mode",
        displayName = "傳送至背後",
        isEnabled = false,
        currentKey = TELEPORT_KEY_INIT,
        ui = {},
        onToggle = function(self, enabled)
            if enabled then
                featuresConfig.anti_aim.isEnabled = false; updateFeatureToggleButton(featuresConfig.anti_aim)
                featuresConfig.flight_mode.isEnabled = false; if setFlightPhysics then setFlightPhysics(false) end; updateFeatureToggleButton(featuresConfig.flight_mode)
                featuresConfig.fake_lag.isEnabled = false; if destroyGhostModel then destroyGhostModel("Teleport enabled") end; updateFeatureToggleButton(featuresConfig.fake_lag)
                print("DEBUG: Anti-Aim, Flight, FakeLag disabled for Teleport.")
            end
            local soundId="rbxassetid://9111384194"; local pitch=enabled and 1 or 0.8; local volume=enabled and 0.5 or 0.3
            game:GetService("SoundService"):PlayLocalSound(Instance.new("Sound",nil,{SoundId=soundId,Volume=volume,Pitch=pitch}))
        end
    },
    anti_aim = {
        id = "anti_aim",
        displayName = "隨機傳送 (AA)",
        isEnabled = false,
        currentKey = ANTI_AIM_KEY_INIT,
        ui = {},
        onToggle = function(self, enabled)
            if enabled then
                featuresConfig.teleport_mode.isEnabled = false; updateFeatureToggleButton(featuresConfig.teleport_mode)
                featuresConfig.flight_mode.isEnabled = false; if setFlightPhysics then setFlightPhysics(false) end; updateFeatureToggleButton(featuresConfig.flight_mode)
                featuresConfig.fake_lag.isEnabled = false; if destroyGhostModel then destroyGhostModel("Anti-Aim enabled") end; updateFeatureToggleButton(featuresConfig.fake_lag)
                print("DEBUG: Teleport, Flight, FakeLag disabled for Anti-Aim.")
            end
            local soundId="rbxassetid://9111384194"; local pitch=enabled and 1.2 or 0.7; local volume=enabled and 0.6 or 0.4
            game:GetService("SoundService"):PlayLocalSound(Instance.new("Sound",nil,{SoundId=soundId,Volume=volume,Pitch=pitch}))
        end
    },
    flight_mode = {
        id = "flight_mode",
        displayName = "飛行模式",
        isEnabled = false,
        currentKey = FLIGHT_TOGGLE_KEY_INIT,
        ui = {},
        onToggle = function(self, enabled)
            if setFlightPhysics then setFlightPhysics(enabled) end
            if enabled then
                featuresConfig.teleport_mode.isEnabled = false; updateFeatureToggleButton(featuresConfig.teleport_mode)
                featuresConfig.anti_aim.isEnabled = false; updateFeatureToggleButton(featuresConfig.anti_aim)
                featuresConfig.fake_lag.isEnabled = false; if destroyGhostModel then destroyGhostModel("Flight enabled") end; updateFeatureToggleButton(featuresConfig.fake_lag)
                print("DEBUG: Teleport, Anti-Aim, FakeLag disabled for Flight.")
            end
            local soundId="rbxassetid://9111384194"; local pitch=enabled and 1.4 or 0.6; local volume=enabled and 0.6 or 0.4
            game:GetService("SoundService"):PlayLocalSound(Instance.new("Sound",nil,{SoundId=soundId,Volume=volume,Pitch=pitch}))
        end
    },
    third_person = {
        id = "third_person",
        displayName = "第三人稱",
        isEnabled = false,
        currentKey = THIRD_PERSON_TOGGLE_KEY_INIT,
        ui = {},
        onToggle = function(self, enabled)
            if enabled then
                 originalCameraType = Camera.CameraType
                 originalCameraFocus = Camera.Focus
                 print("DEBUG: Stored original camera type:", originalCameraType.Name)
                 Camera.CameraType = Enum.CameraType.Scriptable
                 lastThirdPersonPos = nil
            else
                if restoreCamera then restoreCamera() end
            end
        end
    },
    fake_lag = {
        id = "fake_lag",
        displayName = "延遲假身",
        isEnabled = false,
        currentKey = FAKE_LAG_TOGGLE_KEY_INIT,
        ui = {},
        onToggle = function(self, enabled)
            if enabled then
                featuresConfig.teleport_mode.isEnabled = false; updateFeatureToggleButton(featuresConfig.teleport_mode)
                featuresConfig.anti_aim.isEnabled = false; updateFeatureToggleButton(featuresConfig.anti_aim)
                featuresConfig.flight_mode.isEnabled = false; if setFlightPhysics then setFlightPhysics(false) end; updateFeatureToggleButton(featuresConfig.flight_mode)
                print("DEBUG: Teleport, Anti-Aim, Flight disabled for Fake Lag.")
                lastRealCFrameAppliedTime = 0; lastAppliedDelayedCFrame = nil; cframeHistory = {}
                if LocalPlayer.Character and createOrUpdateGhostModel then createOrUpdateGhostModel() end
            else
                if destroyGhostModel then destroyGhostModel("FakeLag toggled OFF") end
            end
            local soundId="rbxassetid://9111384194"; local pitch=enabled and 1.5 or 0.5; local volume=enabled and 0.6 or 0.3
            game:GetService("SoundService"):PlayLocalSound(Instance.new("Sound",nil,{SoundId=soundId,Volume=volume,Pitch=pitch}))
        end
    },
    gui_toggle = { -- This feature controls the GUI visibility itself
        id = "gui_toggle",
        displayName = "開關介面",
        isEnabled = true, -- Corresponds to guiVisible initial state
        currentKey = TOGGLE_GUI_KEY_INIT,
        ui = {}, -- Will have key display and change button, but no toggle button in the list
        onToggle = function(self, enabled)
            -- The mainFrame visibility is handled directly in InputBegan for this key
            -- This onToggle might not be strictly needed if InputBegan handles it all
        end
    }
}
print("DEBUG: featuresConfig initialized.")

-- ========== Helper Functions ==========
print("DEBUG: Defining Helper Functions...")
function getKeyName(inputObject)
    if not inputObject then return "無" end
    local success, name = pcall(function()
        if inputObject:IsA("KeyCode") then return inputObject.Name
        elseif inputObject:IsA("UserInputType") then
            if inputObject == Enum.UserInputType.MouseButton1 then return "滑鼠左鍵"
            elseif inputObject == Enum.UserInputType.MouseButton2 then return "滑鼠右鍵"
            elseif inputObject == Enum.UserInputType.MouseButton3 then return "滑鼠中鍵"
            else return inputObject.Name end
        end
        return "未知"
    end)
    return success and name or "錯誤"
end

function updateFeatureToggleButton(featureConfig)
    if featureConfig and featureConfig.ui and featureConfig.ui.toggleButton then
        local button = featureConfig.ui.toggleButton
        if featureConfig.isEnabled then
            button.Text = featureConfig.displayName .. ": [ 開啟 ]"
            button.TextColor3 = Color3.fromRGB(0, 255, 0)
        else
            button.Text = featureConfig.displayName .. ": [ 關閉 ]"
            button.TextColor3 = Color3.fromRGB(255, 0, 0)
        end
    end
end

function updateFeatureKeyDisplay(featureConfig)
    if featureConfig and featureConfig.ui and featureConfig.ui.keyDisplayLabel then
        featureConfig.ui.keyDisplayLabel.Text = getKeyName(featureConfig.currentKey)
    end
end

function resetButtonStates() -- For keybinding process
    if currentlyBindingFeature then
        local config = featuresConfig[currentlyBindingFeature] or (currentlyBindingFeature == "aimbot_hold" and featuresConfig.aimbot_hold)
        if config and config.ui and config.ui.changeKeyButton then
            config.ui.changeKeyButton.Text = "更改"
            config.ui.changeKeyButton.BackgroundColor3 = Color3.fromRGB(70, 70, 100)
        end
    end
    currentlyBindingFeature = nil
end

-- ========== Fake Lag Helper Functions ==========
function destroyGhostModel(reason)
    if ghostModel then
        print("DEBUG: FakeLag - Destroying ghost model. Reason:", reason or "N/A")
        pcall(function() ghostModel:Destroy() end)
        ghostModel = nil
    end
    cframeHistory = {}
    lastAppliedDelayedCFrame = nil
end

function createOrUpdateGhostModel()
    local character = LocalPlayer.Character
    if not character then
        warn("DEBUG: FakeLag - createOrUpdateGhostModel - LocalPlayer.Character is nil.")
        destroyGhostModel("Character nil in createOrUpdate")
        return false
    end

    local charHRP = character:FindFirstChild("HumanoidRootPart")
    if not charHRP then
        warn("DEBUG: FakeLag - createOrUpdateGhostModel - Character.HumanoidRootPart is nil.")
        destroyGhostModel("HRP nil in createOrUpdate")
        return false
    end
    
    if not ghostModel or not ghostModel.Parent then
        if ghostModel then pcall(function() ghostModel:Destroy() end) end
        print("DEBUG: FakeLag - Attempting to create new ghost model.")

        ghostModel = Instance.new("Model")
        ghostModel.Name = "LocalGhostModel_Player_" .. LocalPlayer.UserId
        ghostModel.Archivable = false

        local partsCloned = 0
        local ghostHRPCreated = false

        for _, part in ipairs(character:GetChildren()) do
            if part:IsA("BasePart") or part:IsA("MeshPart") or part:IsA("Part") then
                local ghostPart = part:Clone()
                ghostPart.Name = "Ghost_" .. part.Name
                ghostPart.Anchored = true
                ghostPart.CanCollide = false
                ghostPart.CastShadow = false
                ghostPart.CanQuery = false
                ghostPart.CanTouch = false
                pcall(function() ghostPart.Transparency = GHOST_TRANSPARENCY end)
                if ghostPart.ClassName == "MeshPart" then
                    local sa = ghostPart:FindFirstChildOfClass("SurfaceAppearance")
                    if sa then sa:Destroy() end
                end
                for _, child in ipairs(ghostPart:GetChildren()) do
                    if child:IsA("Decal") or child:IsA("Texture") or child:IsA("Sparkles") or child:IsA("Fire") or child:IsA("Smoke") or child:IsA("PointLight") or child:IsA("SpotLight") or child:IsA("SurfaceLight") then
                        child:Destroy()
                    end
                end
                ghostPart.Parent = ghostModel
                partsCloned = partsCloned + 1
                if part.Name == "HumanoidRootPart" then
                    ghostModel.PrimaryPart = ghostPart
                    ghostHRPCreated = true
                end
            elseif part:IsA("Accessory") then
                local ghostAccessory = part:Clone()
                ghostAccessory.Name = "Ghost_" .. part.Name
                if ghostAccessory:FindFirstChild("Handle") and ghostAccessory.Handle:IsA("BasePart") then
                    local handle = ghostAccessory.Handle
                    handle.Anchored = true; handle.CanCollide = false; handle.CastShadow = false; handle.CanQuery = false; handle.CanTouch = false
                    pcall(function() handle.Transparency = GHOST_TRANSPARENCY end)
                     if handle.ClassName == "MeshPart" then
                        local sa = handle:FindFirstChildOfClass("SurfaceAppearance")
                        if sa then sa:Destroy() end
                    end
                end
                for _, childDescendant in ipairs(ghostAccessory:GetDescendants()) do
                    if childDescendant:IsA("BasePart") then
                        childDescendant.CanCollide = false; childDescendant.CanTouch = false
                        pcall(function() childDescendant.Transparency = GHOST_TRANSPARENCY end)
                    end
                end
                ghostAccessory.Parent = ghostModel
                partsCloned = partsCloned + 1
            end
        end

        if partsCloned > 0 and ghostHRPCreated then
            ghostModel.Parent = Workspace
        else
            warn("DEBUG: FakeLag - No parts cloned or HRP missing for ghost model. Destroying. Cloned: " .. partsCloned .. ", HRP valid: " .. tostring(ghostHRPCreated))
            if ghostModel then pcall(function() ghostModel:Destroy() end) end
            ghostModel = nil
            return false
        end
    end

    if ghostModel and ghostModel.PrimaryPart and ghostModel.PrimaryPart.Parent == ghostModel then
        local success, err = pcall(function() ghostModel:SetPrimaryPartCFrame(charHRP.CFrame) end)
        if not success then
            warn("DEBUG: FakeLag - Failed to SetPrimaryPartCFrame for ghostModel:", err)
            destroyGhostModel("SetPrimaryPartCFrame failed")
            return false
        end
    elseif ghostModel then
        warn("DEBUG: FakeLag - Ghost model exists but PrimaryPart is invalid/missing.")
        destroyGhostModel("Invalid PrimaryPart state")
        return false
    end
    return true
end
print("DEBUG: Helper Functions defined.")

-- ========== GUI Creation (Redesigned Control Panel) ==========
print("DEBUG: Creating Redesigned Control Panel GUI...")
local controlPanelGui = Instance.new("ScreenGui")
controlPanelGui.Name = "AimbotESPControlPanel_v5"
controlPanelGui.ResetOnSpawn = false
controlPanelGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
controlPanelGui.Parent = PlayerGui

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
-- Adjusted height for more controls. Width can be slightly increased too.
mainFrame.Size = UDim2.new(0, 350, 0, 430)
mainFrame.Position = UDim2.new(0, 10, 0, 10)
mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
mainFrame.BorderColor3 = Color3.fromRGB(80, 80, 80)
mainFrame.BorderSizePixel = 2
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Visible = featuresConfig.gui_toggle.isEnabled -- Initial visibility
mainFrame.Parent = controlPanelGui

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Parent = mainFrame
titleLabel.Text = "niggaLOSE+ v5"
titleLabel.Size = UDim2.new(1, 0, 0, 30)
titleLabel.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.TextSize = 18
titleLabel.TextXAlignment = Enum.TextXAlignment.Center

local currentY = 35 -- Start Y position for feature rows
local itemHeight = 25
local padding = 5
local keyDisplayWidth = 80
local changeButtonWidth = 50
local labelWidth = mainFrame.AbsoluteSize.X - keyDisplayWidth - changeButtonWidth - (padding * 4) - 10 -- Adjust as needed
if labelWidth < 100 then labelWidth = 100 end


-- Create GUI elements for Aimbot and ESP module toggles (these are simpler)
for _, featureId in ipairs({"aimbot_module", "esp_module"}) do
    local config = featuresConfig[featureId]
    if config then
        local toggleButton = Instance.new("TextButton")
        toggleButton.Name = config.id .. "ToggleButton"
        toggleButton.Parent = mainFrame
        toggleButton.Size = UDim2.new(1, -20, 0, itemHeight)
        toggleButton.Position = UDim2.new(0, 10, 0, currentY)
        toggleButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        toggleButton.BorderSizePixel = 1
        toggleButton.Font = Enum.Font.SourceSans
        toggleButton.TextSize = 14
        config.ui.toggleButton = toggleButton -- Store reference

        updateFeatureToggleButton(config) -- Set initial text and color

        toggleButton.MouseButton1Click:Connect(function()
            config.isEnabled = not config.isEnabled
            updateFeatureToggleButton(config)
            if config.onToggle then
                pcall(config.onToggle, config, config.isEnabled)
            end
        end)
        currentY = currentY + itemHeight + padding
    end
end

-- Separator
local separator1 = Instance.new("Frame")
separator1.Parent = mainFrame
separator1.Size = UDim2.new(1, -20, 0, 2)
separator1.Position = UDim2.new(0, 10, 0, currentY)
separator1.BackgroundColor3 = Color3.fromRGB(80,80,80)
separator1.BorderSizePixel = 0
currentY = currentY + 2 + padding

-- Create GUI elements for features with configurable keys + aimbot_hold
local featuresToBuild = {"aimbot_hold", "teleport_mode", "anti_aim", "flight_mode", "third_person", "fake_lag", "gui_toggle"}

for _, featureId in ipairs(featuresToBuild) do
    local config = featuresConfig[featureId]
    if config then
        config.ui = config.ui or {} -- Ensure ui table exists

        -- Feature Name Label
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Name = config.id .. "NameLabel"
        nameLabel.Parent = mainFrame
        nameLabel.Size = UDim2.new(0, labelWidth, 0, itemHeight)
        nameLabel.Position = UDim2.new(0, 10, 0, currentY)
        nameLabel.BackgroundTransparency = 1
        nameLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
        nameLabel.Font = Enum.Font.SourceSans
        nameLabel.TextSize = 14
        nameLabel.Text = config.displayName .. ":"
        nameLabel.TextXAlignment = Enum.TextXAlignment.Left
        config.ui.nameLabel = nameLabel

        -- Current Key Display Label
        local keyDisplay = Instance.new("TextLabel")
        keyDisplay.Name = config.id .. "KeyDisplay"
        keyDisplay.Parent = mainFrame
        keyDisplay.Size = UDim2.new(0, keyDisplayWidth, 0, itemHeight)
        keyDisplay.Position = UDim2.new(0, 10 + labelWidth + padding, 0, currentY)
        keyDisplay.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
        keyDisplay.BorderColor3 = Color3.fromRGB(90,90,90)
        keyDisplay.BorderSizePixel = 1
        keyDisplay.TextColor3 = Color3.fromRGB(200, 200, 255)
        keyDisplay.Font = Enum.Font.SourceSansSemibold
        keyDisplay.TextSize = 13
        keyDisplay.TextXAlignment = Enum.TextXAlignment.Center
        config.ui.keyDisplayLabel = keyDisplay
        updateFeatureKeyDisplay(config) -- Set initial key text

        -- Change Key Button
        local changeButton = Instance.new("TextButton")
        changeButton.Name = config.id .. "ChangeKeyButton"
        changeButton.Parent = mainFrame
        changeButton.Size = UDim2.new(0, changeButtonWidth, 0, itemHeight)
        changeButton.Position = UDim2.new(0, 10 + labelWidth + padding + keyDisplayWidth + padding, 0, currentY)
        changeButton.BackgroundColor3 = Color3.fromRGB(70, 70, 100)
        changeButton.BorderSizePixel = 1
        changeButton.TextColor3 = Color3.fromRGB(220, 220, 255)
        changeButton.Font = Enum.Font.SourceSans
        changeButton.TextSize = 14
        changeButton.Text = "更改"
        config.ui.changeKeyButton = changeButton

        changeButton.MouseButton1Click:Connect(function()
            if currentlyBindingFeature then -- If already binding another key, cancel that first
                local oldConfig = featuresConfig[currentlyBindingFeature] or (currentlyBindingFeature == "aimbot_hold" and featuresConfig.aimbot_hold)
                if oldConfig and oldConfig.ui.changeKeyButton then
                     oldConfig.ui.changeKeyButton.Text = "更改"
                     oldConfig.ui.changeKeyButton.BackgroundColor3 = Color3.fromRGB(70,70,100)
                end
            end
            currentlyBindingFeature = config.id
            changeButton.Text = "按鍵..."
            changeButton.BackgroundColor3 = Color3.fromRGB(100, 100, 70)
        end)
        currentY = currentY + itemHeight + padding
    end
end


-- Separator
local separator2 = Instance.new("Frame")
separator2.Parent = mainFrame
separator2.Size = UDim2.new(1, -20, 0, 2)
separator2.Position = UDim2.new(0, 10, 0, currentY)
separator2.BackgroundColor3 = Color3.fromRGB(80,80,80)
separator2.BorderSizePixel = 0
currentY = currentY + 2 + padding

-- Info Labels for toggled features (to show ON/OFF status since direct toggle buttons are gone for these)
local featureStatusY = currentY
local statusLabelHeight = 18
local statusFeatures = {"teleport_mode", "anti_aim", "flight_mode", "third_person", "fake_lag"}
for i, featureId in ipairs(statusFeatures) do
    local config = featuresConfig[featureId]
    if config then
        local statusLabel = Instance.new("TextLabel")
        statusLabel.Name = config.id .. "StatusLabel"
        statusLabel.Parent = mainFrame
        statusLabel.Size = UDim2.new(1, -20, 0, statusLabelHeight)
        statusLabel.Position = UDim2.new(0, 10, 0, featureStatusY)
        statusLabel.BackgroundTransparency = 1
        statusLabel.Font = Enum.Font.SourceSans
        statusLabel.TextSize = 13
        statusLabel.TextXAlignment = Enum.TextXAlignment.Left
        config.ui.statusLabel = statusLabel

        local function updateStatus()
            if config.isEnabled then
                statusLabel.Text = config.displayName .. ": [ 開啟 ]"
                statusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
            else
                statusLabel.Text = config.displayName .. ": [ 關閉 ]"
                statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
            end
        end
        updateStatus() -- Initial status
        -- Need to connect this update to when the feature's state changes
        -- This can be done by modifying the onToggle or the M1Click on the toggle button (if it existed)
        -- For now, these will be updated when their respective hotkeys are pressed.
        featureStatusY = featureStatusY + statusLabelHeight + (padding / 2)
    end
end
currentY = featureStatusY + padding


local instructionLabel = Instance.new("TextLabel")
instructionLabel.Name = "InstructionLabel"
instructionLabel.Parent = mainFrame
instructionLabel.Size = UDim2.new(1, -20, 0, 40)
instructionLabel.Position = UDim2.new(0, 10, 0, currentY)
instructionLabel.BackgroundTransparency = 1
instructionLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
instructionLabel.Font = Enum.Font.SourceSansItalic
instructionLabel.TextSize = 12
instructionLabel.TextWrapped = true
instructionLabel.Text = "按 Esc 取消按鍵綁定。某些功能（如飛行、傳送）會互相排斥。"
print("DEBUG: Control Panel GUI created.")

-- ========== GUI Creation (Visual Cue Dot) ==========
print("DEBUG: Creating Visual Cue GUI...")
local cueGui=Instance.new("ScreenGui"); cueGui.Name="AimbotVisualCueGui"; cueGui.ResetOnSpawn=false; cueGui.IgnoreGuiInset=true; cueGui.ZIndexBehavior=Enum.ZIndexBehavior.Global; cueGui.DisplayOrder=1000; cueGui.Parent=CoreGui
local cueDot=Instance.new("Frame"); cueDot.Name="CueDot"; cueDot.Size=UDim2.fromOffset(DOT_SIZE.X,DOT_SIZE.Y); cueDot.AnchorPoint=Vector2.new(0.5,0.5); cueDot.Position=UDim2.new(0.5,0,0.5,0); cueDot.BackgroundColor3=DOT_COLOR_NOLOCK; cueDot.BorderSizePixel=0; cueDot.Visible=true; cueDot.Parent=cueGui
local dotCorner=Instance.new("UICorner"); dotCorner.CornerRadius=UDim.new(0.5,0); dotCorner.Parent=cueDot
print("DEBUG: Visual Cue GUI created.")


-- ========== Core Logic Functions (largely unchanged, but using featuresConfig for states) ==========
print("DEBUG: Defining Core Logic Functions...")
local function getNearestPlayer() local closestPlayer=nil; local shortestDistance=math.huge; local localChar=LocalPlayer.Character; local localHRP=localChar and localChar:FindFirstChild("HumanoidRootPart"); if not localChar or not localHRP then return nil end; for _, player in pairs(Players:GetPlayers()) do local char=player.Character; local hrp=char and char:FindFirstChild("HumanoidRootPart"); local head=char and char:FindFirstChild("Head"); local hum=char and char:FindFirstChildOfClass("Humanoid"); if player~=LocalPlayer and hrp and head and hum and hum.Health>0 then local distance=(hrp.Position-localHRP.Position).Magnitude; if distance<shortestDistance then local rayOrigin=Camera.CFrame.Position; local rayDirection=(head.Position-rayOrigin).Unit*distance; local raycastParams=RaycastParams.new(); raycastParams.FilterDescendantsInstances={localChar,Camera,controlPanelGui,cueGui,ghostModel}; raycastParams.FilterType=Enum.RaycastFilterType.Exclude; local raycastResult=Workspace:Raycast(rayOrigin,rayDirection,raycastParams); if not raycastResult or raycastResult.Instance:IsDescendantOf(char) then shortestDistance=distance; closestPlayer=player end end end end; return closestPlayer end
local function teleportBehindPlayer(targetPlayer) local localChar=LocalPlayer.Character; local localHRP=localChar and localChar:FindFirstChild("HumanoidRootPart"); local targetChar=targetPlayer.Character; local targetHRP=targetChar and targetChar:FindFirstChild("HumanoidRootPart"); if not localHRP or not targetHRP then return end; local targetPosition=targetHRP.Position; local targetLookVector=targetHRP.CFrame.LookVector; local behindPosition=targetPosition-(targetLookVector.Unit*TELEPORT_BEHIND_DISTANCE); local teleportPos=Vector3.new(behindPosition.X, localHRP.Position.Y, behindPosition.Z); local lookAtPos=Vector3.new(targetPosition.X, teleportPos.Y, targetPosition.Z); pcall(function() localHRP.CFrame=CFrame.new(teleportPos, lookAtPos) end) end
local function teleportRandomlyAroundPlayer(targetPlayer) local localChar=LocalPlayer.Character; local localHRP=localChar and localChar:FindFirstChild("HumanoidRootPart"); local targetChar=targetPlayer.Character; local targetHRP=targetChar and targetChar:FindFirstChild("HumanoidRootPart"); if not localHRP or not targetHRP then return end; local targetPosition=targetHRP.Position; local randomAngle=math.random()*2*math.pi; local randomRadius=math.random()*ANTI_AIM_RADIUS; local offsetX=math.cos(randomAngle)*randomRadius; local offsetZ=math.sin(randomAngle)*randomRadius; local randomPos=Vector3.new(targetPosition.X+offsetX, localHRP.Position.Y, targetPosition.Z+offsetZ); pcall(function() localHRP.CFrame = CFrame.new(randomPos) * (localHRP.CFrame - localHRP.CFrame.Position) end) end
local function createEspForPlayer(player) if espElements[player] then return end; local elements={}; elements.Box=Drawing.new("Quad"); elements.Box.Color=ESP_BOX_COLOR; elements.Box.Thickness=1; elements.Box.Filled=false; elements.Box.Visible=false; elements.Name=Drawing.new("Text"); elements.Name.Text=player.Name; elements.Name.Color=ESP_TEXT_COLOR; elements.Name.Size=ESP_TEXT_SIZE; elements.Name.Center=true; elements.Name.Outline=true; elements.Name.Visible=false; elements.Health=Drawing.new("Text"); elements.Health.Text="100/100"; elements.Health.Color=ESP_TEXT_COLOR; elements.Health.Size=ESP_HEALTH_SIZE; elements.Health.Center=true; elements.Health.Outline=true; elements.Health.Visible=false; espElements[player]=elements; end
local function removeEspForPlayer(player) if espElements[player] then local elements=espElements[player]; if elements.Box then elements.Box:Remove() end; if elements.Name then elements.Name:Remove() end; if elements.Health then elements.Health:Remove() end; espElements[player]=nil end end
setFlightPhysics = function(enabled) local localChar = LocalPlayer.Character; local hrp = localChar and localChar:FindFirstChild("HumanoidRootPart"); if not hrp then return end; if enabled then print("DEBUG: Enabling flight physics."); if not bodyGyro then bodyGyro = Instance.new("BodyGyro"); bodyGyro.P = 5000; bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9); bodyGyro.CFrame = hrp.CFrame; bodyGyro.Parent = hrp; end; if not bodyVelocity then bodyVelocity = Instance.new("BodyVelocity"); bodyVelocity.P = 1250; bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9); bodyVelocity.Velocity = Vector3.new(0, 0, 0); bodyVelocity.Parent = hrp; end else print("DEBUG: Disabling flight physics."); if bodyGyro then bodyGyro:Destroy(); bodyGyro = nil; end; if bodyVelocity then bodyVelocity:Destroy(); bodyVelocity = nil; end end end
restoreCamera = function() Camera.CameraType = originalCameraType; pcall(function() Camera.Focus = originalCameraFocus end); lastThirdPersonPos = nil; print("DEBUG: Camera restored to default.") end

local function updateThirdPerson()
    local character = LocalPlayer.Character
    local head = character and character:FindFirstChild("Head")
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    local anchorPart = head or hrp
    if not anchorPart then return end
    local anchorPos = anchorPart.Position
    local currentCamCF = Camera.CFrame
    local backwardOffset = -currentCamCF.LookVector * THIRD_PERSON_OFFSET.Z
    local rightOffset = currentCamCF.RightVector * THIRD_PERSON_OFFSET.X
    local upOffset = currentCamCF.UpVector * THIRD_PERSON_OFFSET.Y
    local desiredPos = anchorPos + backwardOffset + rightOffset + upOffset
    local rayOrigin = anchorPos
    local rayDirection = desiredPos - rayOrigin
    local rayMagnitude = rayDirection.Magnitude
    if rayMagnitude < 0.1 then rayMagnitude = 0.1 end
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character, ghostModel}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    local raycastResult = Workspace:Raycast(rayOrigin, rayDirection.Unit * rayMagnitude, raycastParams)
    if raycastResult then desiredPos = raycastResult.Position - rayDirection.Unit * 0.5 end
    if not lastThirdPersonPos then lastThirdPersonPos = desiredPos end
    local smoothedPos = lastThirdPersonPos:Lerp(desiredPos, 1 - THIRD_PERSON_SMOOTHING)
    lastThirdPersonPos = smoothedPos
    if Camera.CameraType ~= Enum.CameraType.Scriptable then Camera.CameraType = Enum.CameraType.Scriptable end
end

local function updateFakeLagLogic()
    if not featuresConfig.fake_lag.isEnabled then
        if ghostModel and ghostModel.Parent then destroyGhostModel("FakeLag deactivated in updateLogic") end
        return
    end
    local character = LocalPlayer.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    if not character or not hrp or not humanoid then print("DEBUG: FakeLag - updateLogic - Character, HRP, or Humanoid missing."); destroyGhostModel("Player char/hrp/hum missing in RenderStepped"); return end
    if hrp.Anchored then warn("DEBUG: FakeLag - Real HRP was anchored! Unanchoring."); hrp.Anchored = false; end
    local ghostModelReady = createOrUpdateGhostModel()
    if not ghostModelReady then print("DEBUG: FakeLag - updateLogic - Ghost model not ready."); return end
    if ghostModel and not ghostModel.Parent then ghostModel.Parent = Workspace
    elseif ghostModel and ghostModel.Parent ~= Workspace then ghostModel.Parent = Workspace end
    local currentCFrame = hrp.CFrame
    local currentTime = tick()
    table.insert(cframeHistory, { timestamp = currentTime, cFrame = currentCFrame })
    local oldestValidRecord = nil; local recordsToRemoveUpTo = 0
    for i = 1, #cframeHistory do local record = cframeHistory[i]; if currentTime - record.timestamp >= GHOST_DELAY_SECONDS then oldestValidRecord = record; recordsToRemoveUpTo = i - 1 else break end end
    if recordsToRemoveUpTo > 0 then for i = 1, recordsToRemoveUpTo do table.remove(cframeHistory, 1) end end
    local targetCFrameToApply = oldestValidRecord and oldestValidRecord.cFrame or nil
    if targetCFrameToApply then
        if not lastAppliedDelayedCFrame or (targetCFrameToApply.Position - lastAppliedDelayedCFrame.Position).Magnitude > 0.01 or (currentTime - lastRealCFrameAppliedTime >= MIN_REAL_CFRAME_UPDATE_INTERVAL) then
            local success = pcall(function() hrp.CFrame = CFrame.new(targetCFrameToApply.Position) * (hrp.CFrame - hrp.CFrame.Position) end)
            if success then lastRealCFrameAppliedTime = currentTime; lastAppliedDelayedCFrame = targetCFrameToApply
            else warn("DEBUG: FakeLag - Failed to set delayed HRP CFrame.") end
        end
    else lastAppliedDelayedCFrame = nil end
    if #cframeHistory > 300 then warn("DEBUG: FakeLag - CFrame history >300, pruning."); table.remove(cframeHistory, 1) end
end
print("DEBUG: Core logic functions defined.")

-- ====================================
-- Main Update Loop (RenderStepped)
-- ====================================
local rsConn
rsConn = RunService.RenderStepped:Connect(function()
    local success, err = pcall(function()
        local localChar = LocalPlayer.Character
        local hrp = localChar and localChar:FindFirstChild("HumanoidRootPart")
        local charHead = localChar and localChar:FindFirstChild("Head")
        if not hrp then return end
        local currentTime = tick()

        if featuresConfig.fake_lag.isEnabled then updateFakeLagLogic() end
        
        local nearestMovementTarget = nil
        if featuresConfig.teleport_mode.isEnabled or featuresConfig.anti_aim.isEnabled then nearestMovementTarget = getNearestPlayer() end

        if featuresConfig.flight_mode.isEnabled then
            local moveVector = Vector3.new(0,0,0); if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVector=moveVector+Vector3.new(0,0,-1) end; if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVector=moveVector+Vector3.new(0,0,1) end; if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVector=moveVector+Vector3.new(-1,0,0) end; if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVector=moveVector+Vector3.new(1,0,0) end; local verticalVelocity=0; if UserInputService:IsKeyDown(Enum.KeyCode.Space) then verticalVelocity=FLIGHT_VERTICAL_SPEED end; if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then verticalVelocity=-FLIGHT_VERTICAL_SPEED end; local worldVelocity=(Camera.CFrame*CFrame.new(moveVector)).Position-Camera.CFrame.Position; worldVelocity=Vector3.new(worldVelocity.X,0,worldVelocity.Z).Unit*FLIGHT_SPEED+Vector3.new(0,verticalVelocity,0); if bodyVelocity then bodyVelocity.Velocity=worldVelocity end; if bodyGyro then bodyGyro.CFrame=Camera.CFrame end
        elseif featuresConfig.anti_aim.isEnabled and nearestMovementTarget then teleportRandomlyAroundPlayer(nearestMovementTarget)
        elseif featuresConfig.teleport_mode.isEnabled and nearestMovementTarget then teleportBehindPlayer(nearestMovementTarget)
        end

        if featuresConfig.third_person.isEnabled then updateThirdPerson()
        elseif Camera.CameraType == Enum.CameraType.Scriptable and not featuresConfig.aimbot_module.isEnabled then restoreCamera() end

        local isAiming = false
        if featuresConfig.aimbot_hold.currentKey then
            if featuresConfig.aimbot_hold.currentKey:IsA("UserInputType") then isAiming = UserInputService:IsMouseButtonPressed(featuresConfig.aimbot_hold.currentKey)
            elseif featuresConfig.aimbot_hold.currentKey:IsA("KeyCode") then isAiming = UserInputService:IsKeyDown(featuresConfig.aimbot_hold.currentKey) end
        end

        local aimbotTargetPlayer = nil
        if featuresConfig.aimbot_module.isEnabled and isAiming then aimbotTargetPlayer = getNearestPlayer() end

        local isLocked = false; local newCameraCFrame = nil
        if aimbotTargetPlayer then
            local targetHead = aimbotTargetPlayer.Character and aimbotTargetPlayer.Character:FindFirstChild("Head")
            if targetHead then
                isLocked = true
                if featuresConfig.third_person.isEnabled then
                    if charHead and lastThirdPersonPos then newCameraCFrame = CFrame.new(lastThirdPersonPos, lastThirdPersonPos + (targetHead.Position - charHead.Position).Unit)
                    else isLocked = false; warn("DEBUG: TP Aim failed - Missing Character Head or lastThirdPersonPos") end
                else newCameraCFrame = CFrame.new(Camera.CFrame.Position, targetHead.Position) end
            end
        end

        if isLocked and newCameraCFrame then pcall(function() Camera.CFrame = newCameraCFrame end)
        elseif featuresConfig.third_person.isEnabled and lastThirdPersonPos then
             local lookAtPos = (charHead or hrp).Position; pcall(function() Camera.CFrame = CFrame.new(lastThirdPersonPos, lookAtPos) end)
        elseif not featuresConfig.third_person.isEnabled and Camera.CameraType == Enum.CameraType.Scriptable and not (featuresConfig.aimbot_module.isEnabled and isAiming) then
            restoreCamera()
        end

        cueDot.BackgroundColor3 = isLocked and DOT_COLOR_LOCKED or DOT_COLOR_NOLOCK

        local shouldBeShooting = isLocked
        if shouldBeShooting then
            if currentTime - lastClickTime >= TRIGGERBOT_CLICK_INTERVAL then
                if typeof(mouse1press) == "function" then pcall(mouse1press) end
                if typeof(mouse1release) == "function" then pcall(mouse1release) end
                lastClickTime = currentTime
            end
        elseif lastShootingState then if typeof(mouse1release) == "function" then pcall(mouse1release) end end
        lastShootingState = shouldBeShooting
        
        if featuresConfig.esp_module.isEnabled then
             for _, player in pairs(Players:GetPlayers()) do if player==LocalPlayer then continue end; local char=player.Character; local hum=char and char:FindFirstChildOfClass("Humanoid"); local hrpEsp=char and char:FindFirstChild("HumanoidRootPart"); local headEsp=char and char:FindFirstChild("Head"); if hum and hrpEsp and headEsp and hum.Health>0 then if not espElements[player] then createEspForPlayer(player) end; local elements=espElements[player]; if not elements then continue end; local headPos,headVisible=Camera:WorldToViewportPoint(headEsp.Position+Vector3.new(0,0.5,0)); local hrpPos,hrpVisible=Camera:WorldToViewportPoint(hrpEsp.Position); if headVisible and hrpVisible then local boxHeight=math.abs(headPos.Y-hrpPos.Y); local boxWidth=boxHeight/2; local topLeft=Vector2.new(headPos.X-boxWidth/2,headPos.Y); local bottomRight=Vector2.new(hrpPos.X+boxWidth/2,hrpPos.Y); elements.Box.PointA=topLeft; elements.Box.PointB=Vector2.new(topLeft.X+boxWidth,topLeft.Y); elements.Box.PointC=Vector2.new(bottomRight.X,bottomRight.Y); elements.Box.PointD=Vector2.new(bottomRight.X-boxWidth,bottomRight.Y); elements.Box.Visible=true; elements.Name.Position=Vector2.new(headPos.X,headPos.Y-ESP_TEXT_SIZE-2); elements.Name.Visible=true; local healthText=math.floor(hum.Health).."/"..math.floor(hum.MaxHealth); elements.Health.Text=healthText; elements.Health.Position=Vector2.new(hrpPos.X,bottomRight.Y+2); elements.Health.Visible=true else elements.Box.Visible=false; elements.Name.Visible=false; elements.Health.Visible=false end else if espElements[player] then local elements=espElements[player]; elements.Box.Visible=false; elements.Name.Visible=false; elements.Health.Visible=false end end end
        else -- ESP module is OFF
            if next(espElements) then -- Check if espElements is not empty before iterating
                for _, elements in pairs(espElements) do if elements.Box then elements.Box.Visible = false end; if elements.Name then elements.Name.Visible = false end; if elements.Health then elements.Health.Visible = false end end
            end
        end

    end)
    if not success then warn("DEBUG: ERROR in RenderStepped:", err) end
end)
print("DEBUG: RenderStepped connected.")

-- ========== Player Added/Removed Handlers ==========
print("DEBUG: Connecting Player Handlers (ESP)...")
Players.PlayerAdded:Connect(createEspForPlayer)
Players.PlayerRemoving:Connect(removeEspForPlayer)
for _, player in pairs(Players:GetPlayers()) do if player ~= LocalPlayer then createEspForPlayer(player) end end
print("DEBUG: Initial players processed for ESP.")

-- ========== Character Added/Removed Handlers (Fake Lag) ==========
print("DEBUG: Connecting Character Handlers (FakeLag)...")
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    print("DEBUG: FakeLag - Player character ADDED:", newCharacter.Name)
    destroyGhostModel("New character added")
    if featuresConfig.fake_lag.isEnabled then
        task.wait(0.1)
        if LocalPlayer.Character == newCharacter then
            print("DEBUG: FakeLag - CharacterAdded: FakeLag is active, creating ghost.")
            createOrUpdateGhostModel()
        end
    end
end)
LocalPlayer.CharacterRemoving:Connect(function(oldCharacter)
    print("DEBUG: FakeLag - Player character REMOVING:", oldCharacter.Name)
    destroyGhostModel("Character removing")
end)
print("DEBUG: Character Handlers (FakeLag) connected.")

-- ========== Input Handling ==========
print("DEBUG: Connecting Input Handling...")
local inputConn
inputConn = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if currentlyBindingFeature then
        print("DEBUG: Handling Keybind Input for feature:", currentlyBindingFeature)
        if input.KeyCode == CANCEL_BIND_KEY then
            print("DEBUG: Keybind Cancelled.")
            resetButtonStates()
            return
        end

        local featureConf = featuresConfig[currentlyBindingFeature]
        if not featureConf then -- Should not happen if currentlyBindingFeature is set correctly
             warn("DEBUG: Keybind - No config found for", currentlyBindingFeature)
             resetButtonStates()
             return
        end

        -- Check for reserved keys (keys used by other features or system keys)
        local isReserved = false
        if input.UserInputType == Enum.UserInputType.Keyboard then
            local k = input.KeyCode
            if k==Enum.KeyCode.LeftShift or k==Enum.KeyCode.RightShift or k==Enum.KeyCode.LeftControl or k==Enum.KeyCode.RightControl or k==Enum.KeyCode.LeftAlt or k==Enum.KeyCode.RightAlt or k==Enum.KeyCode.LeftSuper or k==Enum.KeyCode.RightSuper or k==Enum.KeyCode.CapsLock or k==Enum.KeyCode.Tab or k==CANCEL_BIND_KEY then
                isReserved = true
            else -- Check against other features' current keys
                for id, confItem in pairs(featuresConfig) do
                    if id ~= currentlyBindingFeature and confItem.currentKey == k then
                        isReserved = true; print("DEBUG: Keybind - Key already used by", id); break
                    end
                end
            end
        end
        if isReserved then print("DEBUG: Ignored Reserved/System Key for binding."); return end

        local newKey
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.MouseButton2 or input.UserInputType == Enum.UserInputType.MouseButton3 then newKey = input.UserInputType
        elseif input.UserInputType == Enum.UserInputType.Keyboard then newKey = input.KeyCode
        else print("DEBUG: Binding failed - Unsupported type:", input.UserInputType.Name); resetButtonStates(); return end
        
        print("DEBUG: New Key Bound for", currentlyBindingFeature, ":", getKeyName(newKey))
        featureConf.currentKey = newKey
        updateFeatureKeyDisplay(featureConf)
        resetButtonStates()
        return
    end

    if gameProcessedEvent then return end

    -- Handle feature toggles based on their currentKey
    for featureId, config in pairs(featuresConfig) do
        if config.currentKey and input.KeyCode == config.currentKey then
            if featureId == "gui_toggle" then -- Special handling for GUI toggle
                featuresConfig.gui_toggle.isEnabled = not featuresConfig.gui_toggle.isEnabled
                mainFrame.Visible = featuresConfig.gui_toggle.isEnabled
                UserInputService.MouseBehavior = Enum.MouseBehavior.Default
                UserInputService.MouseIconEnabled = featuresConfig.gui_toggle.isEnabled
                print("DEBUG: GUI Visibility Toggled:", featuresConfig.gui_toggle.isEnabled)
            else
                config.isEnabled = not config.isEnabled
                print("DEBUG:", config.displayName, "Toggled:", config.isEnabled and "ON" or "OFF")
                if config.ui and config.ui.statusLabel then -- Update status label if it exists
                     if config.isEnabled then config.ui.statusLabel.Text = config.displayName .. ": [ 開啟 ]"; config.ui.statusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
                     else config.ui.statusLabel.Text = config.displayName .. ": [ 關閉 ]"; config.ui.statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100) end
                end
                if config.onToggle then
                    pcall(config.onToggle, config, config.isEnabled)
                end
            end
            return -- Consume the input
        end
    end
end)
print("DEBUG: Input Handling connected.")

-- ========== Initialization ==========
if featuresConfig.gui_toggle.isEnabled then
    print("DEBUG: Setting initial mouse state for visible GUI.")
    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    UserInputService.MouseIconEnabled = true
else
    UserInputService.MouseIconEnabled = false -- Ensure mouse is hidden if GUI starts hidden
end


-- Cleanup function
local function cleanup()
    print("DEBUG: Script cleanup initiated...")
    if rsConn then rsConn:Disconnect(); rsConn=nil end
    -- Disconnect GUI button clicks dynamically created (if needed, but Destroy should handle)
    if inputConn then inputConn:Disconnect(); inputConn=nil end
    setFlightPhysics(false)
    destroyGhostModel("Script cleanup")
    for player, _ in pairs(espElements) do removeEspForPlayer(player) end
    if controlPanelGui and controlPanelGui.Parent then controlPanelGui:Destroy() end
    if cueGui and cueGui.Parent then cueGui:Destroy() end
    if featuresConfig.third_person.isEnabled then pcall(restoreCamera) end
    print("DEBUG: Cleanup complete.")
end
if script and typeof(script) == "Instance" then script.Destroying:Connect(cleanup) end
