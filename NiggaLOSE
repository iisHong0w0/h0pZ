-- 看三小
-- 看三小
-- 看三小
-- 看三小
-- 看三小
-- 看三小
-- 看三小
-- 看三小
-- 看三小
-- 看三小
-- 看三小
-- 看三小
-- 看三小
-- 看三小
-- 看三小
-- 看三小
-- 看三小
-- 哈哈
-- ========== Roblox Services ==========
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
print("DEBUG: Services loaded.")

-- ========== Drawing Library Check (CRUCIAL FOR ESP) ==========
local DrawingLib = nil
if typeof(Drawing) == "table" and typeof(Drawing.new) == "function" then
    DrawingLib = Drawing
    print("DEBUG: Drawing library found and seems valid.")
else
    warn("DEBUG: WARNING - 'Drawing' library not found or invalid. ESP will be disabled.")
end

-- ========== Player & Camera ==========
local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then warn("DEBUG: FATAL - LocalPlayer not found!") return end
print("DEBUG: LocalPlayer found:", LocalPlayer.Name)
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
if not PlayerGui then warn("DEBUG: FATAL - PlayerGui not found after wait!") return end
print("DEBUG: PlayerGui loaded.")
local Camera = Workspace.CurrentCamera
if not Camera then warn("DEBUG: FATAL - Workspace.CurrentCamera not found!") return end
print("DEBUG: Camera found.")

-- ========== Initial Default Configuration (Keys will be managed by featuresConfig later) ==========
local DEFAULT_AIMBOT_HOLD_KEY_INIT = Enum.UserInputType.MouseButton2
local TOGGLE_GUI_KEY_INIT = Enum.KeyCode.Insert
local CANCEL_BIND_KEY = Enum.KeyCode.Escape
local TELEPORT_KEY_INIT = Enum.KeyCode.H
local ANTI_AIM_KEY_INIT = Enum.KeyCode.N
local FLIGHT_TOGGLE_KEY_INIT = Enum.KeyCode.V
local THIRD_PERSON_TOGGLE_KEY_INIT = Enum.KeyCode.T
local FAKE_LAG_TOGGLE_KEY_INIT = Enum.KeyCode.X

local TELEPORT_BEHIND_DISTANCE = 3
local ANTI_AIM_RADIUS = 5
local INITIAL_FLIGHT_SPEED = 50
local MIN_FLIGHT_SPEED = 10
local MAX_FLIGHT_SPEED = 200
local FLIGHT_VERTICAL_SPEED = 30
local TRIGGERBOT_CLICK_INTERVAL = 0

local DOT_COLOR_NOLOCK=Color3.fromRGB(255,255,255); local DOT_COLOR_LOCKED=Color3.fromRGB(255,0,0); local DOT_SIZE=Vector2.new(4,4)
local ESP_BOX_COLOR=Color3.fromRGB(0,150,255); local ESP_TEXT_COLOR=Color3.fromRGB(255,255,255); local ESP_TEXT_SIZE=14; local ESP_HEALTH_SIZE=12

local THIRD_PERSON_OFFSET = Vector3.new(1.5, 2, 8)
local THIRD_PERSON_SMOOTHING = 0.1

local GHOST_DELAY_SECONDS = 1
local GHOST_TRANSPARENCY = 0.5
local MIN_REAL_CFRAME_UPDATE_INTERVAL = 0.5
print("DEBUG: Initial default configurations set.")

-- ========== State Variables (Many will be managed by featuresConfig) ==========
local espElements = {}
local lastShootingState = false
local lastClickTime = 0
local bodyVelocity = nil
local bodyGyro = nil
local originalCameraType = Camera.CameraType
local originalCameraFocus = Camera.Focus
local lastThirdPersonPos = nil
local ghostModel = nil
local cframeHistory = {}
local lastRealCFrameAppliedTime = 0
local lastAppliedDelayedCFrame = nil
local currentlyBindingFeature = nil
local originalHumanoidState = nil

print("DEBUG: Core state variables initialized.")

-- Forward declaration for functions used in featuresConfig or later
local setFlightPhysics, destroyGhostModel, createOrUpdateGhostModel, restoreCamera, updateFeatureToggleButton, updateFeatureKeyDisplay, setNoclipState
-- Note: updateFeatureToggleButton, updateFeatureKeyDisplay, getKeyName, resetButtonStates will be defined before GUI creation

-- ========== Features Configuration & State Management Table ==========
local featuresConfig = {
    aimbot_module = {
        id = "aimbot_module",
        displayName = "自動瞄準模組",
        isEnabled = true,
        ui = {},
    },
    esp_module = {
        id = "esp_module",
        displayName = "ESP透視模組",
        isEnabled = DrawingLib ~= nil, -- Enable only if DrawingLib is found
        ui = {},
        onToggle = function(self, enabled)
            if not DrawingLib then
                if self.ui.toggleButton then
                    self.isEnabled = false
                    if updateFeatureToggleButton then updateFeatureToggleButton(self) end
                end
                return
            end
            if not enabled then
                for _, elements in pairs(espElements) do
                    if elements.Box then elements.Box.Visible = false end
                    if elements.Name then elements.Name.Visible = false end
                    if elements.Health then elements.Health.Visible = false end
                end
            end
        end
    },
    aimbot_hold = {
        id = "aimbot_hold",
        displayName = "按住瞄準鍵",
        currentKey = DEFAULT_AIMBOT_HOLD_KEY_INIT,
        ui = {},
    },
    teleport_mode = {
        id = "teleport_mode",
        displayName = "傳送至背後",
        isEnabled = false,
        currentKey = TELEPORT_KEY_INIT,
        ui = {},
        onToggle = function(self, enabled)
            if enabled then
                featuresConfig.anti_aim.isEnabled = false; if featuresConfig.anti_aim.ui.statusLabel and updateFeatureToggleButton then updateFeatureToggleButton(featuresConfig.anti_aim) end
                featuresConfig.flight_mode.isEnabled = false; if setFlightPhysics then setFlightPhysics(false) end; if setNoclipState then setNoclipState(false) end; if featuresConfig.flight_mode.ui.statusLabel and updateFeatureToggleButton then updateFeatureToggleButton(featuresConfig.flight_mode) end
                featuresConfig.fake_lag.isEnabled = false; if destroyGhostModel then destroyGhostModel("Teleport enabled") end; if featuresConfig.fake_lag.ui.statusLabel and updateFeatureToggleButton then updateFeatureToggleButton(featuresConfig.fake_lag) end
            end
            local soundId="rbxassetid://9111384194"; local pitch=enabled and 1 or 0.8; local volume=enabled and 0.5 or 0.3
            game:GetService("SoundService"):PlayLocalSound(Instance.new("Sound",nil,{SoundId=soundId,Volume=volume,Pitch=pitch}))
        end
    },
    anti_aim = {
        id = "anti_aim",
        displayName = "隨機傳送 (AA)",
        isEnabled = false,
        currentKey = ANTI_AIM_KEY_INIT,
        ui = {},
        onToggle = function(self, enabled)
            if enabled then
                featuresConfig.teleport_mode.isEnabled = false; if featuresConfig.teleport_mode.ui.statusLabel and updateFeatureToggleButton then updateFeatureToggleButton(featuresConfig.teleport_mode) end
                featuresConfig.flight_mode.isEnabled = false; if setFlightPhysics then setFlightPhysics(false) end; if setNoclipState then setNoclipState(false) end; if featuresConfig.flight_mode.ui.statusLabel and updateFeatureToggleButton then updateFeatureToggleButton(featuresConfig.flight_mode) end
                featuresConfig.fake_lag.isEnabled = false; if destroyGhostModel then destroyGhostModel("Anti-Aim enabled") end; if featuresConfig.fake_lag.ui.statusLabel and updateFeatureToggleButton then updateFeatureToggleButton(featuresConfig.fake_lag) end
            end
            local soundId="rbxassetid://9111384194"; local pitch=enabled and 1.2 or 0.7; local volume=enabled and 0.6 or 0.4
            game:GetService("SoundService"):PlayLocalSound(Instance.new("Sound",nil,{SoundId=soundId,Volume=volume,Pitch=pitch}))
        end
    },
    flight_mode = {
        id = "flight_mode",
        displayName = "飛行模式",
        isEnabled = false,
        currentKey = FLIGHT_TOGGLE_KEY_INIT,
        currentSpeed = INITIAL_FLIGHT_SPEED,
        ui = {},
        onToggle = function(self, enabled)
            if setFlightPhysics then setFlightPhysics(enabled) end
            if setNoclipState then setNoclipState(enabled) end
            if enabled then
                featuresConfig.teleport_mode.isEnabled = false; if featuresConfig.teleport_mode.ui.statusLabel and updateFeatureToggleButton then updateFeatureToggleButton(featuresConfig.teleport_mode) end
                featuresConfig.anti_aim.isEnabled = false; if featuresConfig.anti_aim.ui.statusLabel and updateFeatureToggleButton then updateFeatureToggleButton(featuresConfig.anti_aim) end
                featuresConfig.fake_lag.isEnabled = false; if destroyGhostModel then destroyGhostModel("Flight enabled") end; if featuresConfig.fake_lag.ui.statusLabel and updateFeatureToggleButton then updateFeatureToggleButton(featuresConfig.fake_lag) end
            end
            local soundId="rbxassetid://9111384194"; local pitch=enabled and 1.4 or 0.6; local volume=enabled and 0.6 or 0.4
            game:GetService("SoundService"):PlayLocalSound(Instance.new("Sound",nil,{SoundId=soundId,Volume=volume,Pitch=pitch}))
        end
    },
    third_person = {
        id = "third_person",
        displayName = "第三人稱",
        isEnabled = false,
        currentKey = THIRD_PERSON_TOGGLE_KEY_INIT,
        ui = {},
        onToggle = function(self, enabled)
            if enabled then
                 originalCameraType = Camera.CameraType
                 originalCameraFocus = Camera.Focus
                 Camera.CameraType = Enum.CameraType.Scriptable
                 lastThirdPersonPos = nil
            else
                if restoreCamera then restoreCamera() end
            end
        end
    },
    fake_lag = {
        id = "fake_lag",
        displayName = "延遲假身",
        isEnabled = false,
        currentKey = FAKE_LAG_TOGGLE_KEY_INIT,
        ui = {},
        onToggle = function(self, enabled)
            if enabled then
                featuresConfig.teleport_mode.isEnabled = false; if featuresConfig.teleport_mode.ui.statusLabel and updateFeatureToggleButton then updateFeatureToggleButton(featuresConfig.teleport_mode) end
                featuresConfig.anti_aim.isEnabled = false; if featuresConfig.anti_aim.ui.statusLabel and updateFeatureToggleButton then updateFeatureToggleButton(featuresConfig.anti_aim) end
                featuresConfig.flight_mode.isEnabled = false; if setFlightPhysics then setFlightPhysics(false) end; if setNoclipState then setNoclipState(false) end; if featuresConfig.flight_mode.ui.statusLabel and updateFeatureToggleButton then updateFeatureToggleButton(featuresConfig.flight_mode) end
                lastRealCFrameAppliedTime = 0; lastAppliedDelayedCFrame = nil; cframeHistory = {}
                if LocalPlayer.Character and createOrUpdateGhostModel then createOrUpdateGhostModel() end
            else
                if destroyGhostModel then destroyGhostModel("FakeLag toggled OFF") end
            end
            local soundId="rbxassetid://9111384194"; local pitch=enabled and 1.5 or 0.5; local volume=enabled and 0.6 or 0.3
            game:GetService("SoundService"):PlayLocalSound(Instance.new("Sound",nil,{SoundId=soundId,Volume=volume,Pitch=pitch}))
        end
    },
    gui_toggle = {
        id = "gui_toggle",
        displayName = "開關介面",
        isEnabled = true,
        currentKey = TOGGLE_GUI_KEY_INIT,
        ui = {},
    }
}
print("DEBUG: featuresConfig initialized.")

if not DrawingLib and featuresConfig.esp_module.isEnabled then
    featuresConfig.esp_module.isEnabled = false
end

-- ========== Helper Functions (Defined BEFORE GUI Creation that uses them) ==========
function getKeyName(inputObject)
    if not inputObject then return "無" end
    local success, name = pcall(function()
        if inputObject:IsA("KeyCode") then return inputObject.Name
        elseif inputObject:IsA("UserInputType") then
            if inputObject == Enum.UserInputType.MouseButton1 then return "滑鼠左鍵"
            elseif inputObject == Enum.UserInputType.MouseButton2 then return "滑鼠右鍵"
            elseif inputObject == Enum.UserInputType.MouseButton3 then return "滑鼠中鍵"
            else return inputObject.Name end
        end
        return "未知"
    end)
    return success and name or "錯誤"
end

updateFeatureToggleButton = function(featureConfig)
    if featureConfig and featureConfig.ui then
        if featureConfig.ui.toggleButton then
            local button = featureConfig.ui.toggleButton
            if featureConfig.isEnabled then
                button.Text = featureConfig.displayName .. ": [ 開啟 ]"; button.TextColor3 = Color3.fromRGB(0, 255, 0)
            else
                button.Text = featureConfig.displayName .. ": [ 關閉 ]"; button.TextColor3 = Color3.fromRGB(255, 0, 0)
            end
        elseif featureConfig.ui.statusLabel then
            if featureConfig.isEnabled then
                featureConfig.ui.statusLabel.Text = featureConfig.displayName .. ": [ 開啟 ]"; featureConfig.ui.statusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
            else
                featureConfig.ui.statusLabel.Text = featureConfig.displayName .. ": [ 關閉 ]"; featureConfig.ui.statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
            end
        end
    end
end

updateFeatureKeyDisplay = function(featureConfig)
    if featureConfig and featureConfig.ui and featureConfig.ui.keyDisplayLabel then
        featureConfig.ui.keyDisplayLabel.Text = getKeyName(featureConfig.currentKey)
    end
end

resetButtonStates = function()
    if currentlyBindingFeature then
        local config = featuresConfig[currentlyBindingFeature]
        if config and config.ui and config.ui.changeKeyButton then
            config.ui.changeKeyButton.Text = "更改"; config.ui.changeKeyButton.BackgroundColor3 = Color3.fromRGB(70, 70, 100)
        end
    end
    currentlyBindingFeature = nil
end

-- ========== GUI Creation (Redesigned Control Panel) ==========
-- (GUI Code from your previous working script, with minor version bump if you wish)
print("DEBUG: Creating Redesigned Control Panel GUI...")
local controlPanelGui = Instance.new("ScreenGui")
controlPanelGui.Name = "AimbotESPControlPanel_v5_3_Solara" -- Indicate Solara version
controlPanelGui.ResetOnSpawn = false
controlPanelGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
controlPanelGui.Parent = PlayerGui

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 350, 0, 480)
mainFrame.Position = UDim2.new(0, 10, 0, 10)
mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
mainFrame.BorderColor3 = Color3.fromRGB(80, 80, 80)
mainFrame.BorderSizePixel = 2
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = controlPanelGui
mainFrame.Visible = featuresConfig.gui_toggle.isEnabled

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Parent = mainFrame
titleLabel.Text = "niggaLOSE+ v5.3S" -- Indicate Solara version
titleLabel.Size = UDim2.new(1, 0, 0, 30)
titleLabel.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.TextSize = 18
titleLabel.TextXAlignment = Enum.TextXAlignment.Center

local currentY = 35
local itemHeight = 25
local padding = 5
local keyDisplayWidth = 80
local changeButtonWidth = 50
local labelWidth = mainFrame.AbsoluteSize.X - keyDisplayWidth - changeButtonWidth - (padding * 4) - 10
if labelWidth < 100 then labelWidth = 100 end
if mainFrame.AbsoluteSize.X == 0 then labelWidth = 350 - keyDisplayWidth - changeButtonWidth - (padding * 4) - 10; if labelWidth < 100 then labelWidth = 100 end end


for _, featureId in ipairs({"aimbot_module", "esp_module"}) do
    local config = featuresConfig[featureId]
    if config then
        local toggleButton = Instance.new("TextButton")
        toggleButton.Name = config.id .. "ToggleButton"; toggleButton.Parent = mainFrame
        toggleButton.Size = UDim2.new(1, -20, 0, itemHeight); toggleButton.Position = UDim2.new(0, 10, 0, currentY)
        toggleButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60); toggleButton.BorderSizePixel = 1
        toggleButton.Font = Enum.Font.SourceSans; toggleButton.TextSize = 14
        config.ui.toggleButton = toggleButton
        updateFeatureToggleButton(config)
        toggleButton.MouseButton1Click:Connect(function()
            config.isEnabled = not config.isEnabled
            updateFeatureToggleButton(config)
            if config.onToggle then pcall(config.onToggle, config, config.isEnabled) end
        end)
        currentY = currentY + itemHeight + padding
    end
end

local separator1 = Instance.new("Frame"); separator1.Parent = mainFrame
separator1.Size = UDim2.new(1, -20, 0, 2); separator1.Position = UDim2.new(0, 10, 0, currentY)
separator1.BackgroundColor3 = Color3.fromRGB(80,80,80); separator1.BorderSizePixel = 0
currentY = currentY + 2 + padding

local featuresToBuild = {"aimbot_hold", "teleport_mode", "anti_aim", "flight_mode", "third_person", "fake_lag", "gui_toggle"}
for _, featureId in ipairs(featuresToBuild) do
    local config = featuresConfig[featureId]
    if config then
        config.ui = config.ui or {}
        local nameLabel = Instance.new("TextLabel"); nameLabel.Name = config.id .. "NameLabel"; nameLabel.Parent = mainFrame
        nameLabel.Size = UDim2.new(0, labelWidth, 0, itemHeight); nameLabel.Position = UDim2.new(0, 10, 0, currentY)
        nameLabel.BackgroundTransparency = 1; nameLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
        nameLabel.Font = Enum.Font.SourceSans; nameLabel.TextSize = 14; nameLabel.Text = config.displayName .. ":"; nameLabel.TextXAlignment = Enum.TextXAlignment.Left
        config.ui.nameLabel = nameLabel
        local keyDisplay = Instance.new("TextLabel"); keyDisplay.Name = config.id .. "KeyDisplay"; keyDisplay.Parent = mainFrame
        keyDisplay.Size = UDim2.new(0, keyDisplayWidth, 0, itemHeight); keyDisplay.Position = UDim2.new(0, 10 + labelWidth + padding, 0, currentY)
        keyDisplay.BackgroundColor3 = Color3.fromRGB(55, 55, 55); keyDisplay.BorderColor3 = Color3.fromRGB(90,90,90); keyDisplay.BorderSizePixel = 1
        keyDisplay.TextColor3 = Color3.fromRGB(200, 200, 255); keyDisplay.Font = Enum.Font.SourceSansSemibold; keyDisplay.TextSize = 13; keyDisplay.TextXAlignment = Enum.TextXAlignment.Center
        config.ui.keyDisplayLabel = keyDisplay; updateFeatureKeyDisplay(config)
        local changeButton = Instance.new("TextButton"); changeButton.Name = config.id .. "ChangeKeyButton"; changeButton.Parent = mainFrame
        changeButton.Size = UDim2.new(0, changeButtonWidth, 0, itemHeight); changeButton.Position = UDim2.new(0, 10 + labelWidth + padding + keyDisplayWidth + padding, 0, currentY)
        changeButton.BackgroundColor3 = Color3.fromRGB(70, 70, 100); changeButton.BorderSizePixel = 1; changeButton.TextColor3 = Color3.fromRGB(220, 220, 255)
        changeButton.Font = Enum.Font.SourceSans; changeButton.TextSize = 14; changeButton.Text = "更改"
        config.ui.changeKeyButton = changeButton
        changeButton.MouseButton1Click:Connect(function()
            if currentlyBindingFeature then local oldConfig = featuresConfig[currentlyBindingFeature]; if oldConfig and oldConfig.ui.changeKeyButton then oldConfig.ui.changeKeyButton.Text = "更改"; oldConfig.ui.changeKeyButton.BackgroundColor3 = Color3.fromRGB(70,70,100) end end
            currentlyBindingFeature = config.id; changeButton.Text = "按鍵..."; changeButton.BackgroundColor3 = Color3.fromRGB(100, 100, 70)
        end)
        currentY = currentY + itemHeight + padding
        if featureId == "flight_mode" then
            local sliderTrack = Instance.new("Frame"); sliderTrack.Name = "FlightSpeedSliderTrack"; sliderTrack.Parent = mainFrame
            local sliderTrackWidth = mainFrame.AbsoluteSize.X - 20 - 50 - 10; if mainFrame.AbsoluteSize.X == 0 then sliderTrackWidth = 350 - 20 - 50 - 10 end
            sliderTrack.Size = UDim2.new(0, sliderTrackWidth, 0, 10); sliderTrack.Position = UDim2.new(0, 10, 0, currentY)
            sliderTrack.BackgroundColor3 = Color3.fromRGB(30, 30, 30); sliderTrack.BorderSizePixel = 1; sliderTrack.BorderColor3 = Color3.fromRGB(70,70,70)
            config.ui.sliderTrack = sliderTrack
            local sliderThumb = Instance.new("Frame"); sliderThumb.Name = "FlightSpeedSliderThumb"; sliderThumb.Parent = sliderTrack
            sliderThumb.Size = UDim2.new(0, 10, 1, 4); sliderThumb.Position = UDim2.new(0, 0, 0, -2)
            sliderThumb.BackgroundColor3 = Color3.fromRGB(100, 100, 220); sliderThumb.BorderSizePixel = 1; sliderThumb.BorderColor3 = Color3.fromRGB(150,150,255)
            config.ui.sliderThumb = sliderThumb
            local speedDisplayLabel = Instance.new("TextLabel"); speedDisplayLabel.Name = "FlightSpeedDisplay"; speedDisplayLabel.Parent = mainFrame
            speedDisplayLabel.Size = UDim2.new(0, 45, 0, itemHeight - 5); speedDisplayLabel.Position = UDim2.new(0, 10 + sliderTrackWidth + 5, 0, currentY - ((itemHeight - 5)/2) + 5 - 2.5 )
            speedDisplayLabel.BackgroundTransparency = 1; speedDisplayLabel.TextColor3 = Color3.fromRGB(200, 200, 255); speedDisplayLabel.Font = Enum.Font.SourceSansSemibold
            speedDisplayLabel.TextSize = 12; speedDisplayLabel.TextXAlignment = Enum.TextXAlignment.Right
            config.ui.speedDisplayLabel = speedDisplayLabel
            local function updateSliderFromSpeed(speed) local percentage = math.clamp((speed - MIN_FLIGHT_SPEED) / (MAX_FLIGHT_SPEED - MIN_FLIGHT_SPEED), 0, 1); sliderThumb.Position = UDim2.new(percentage, -sliderThumb.AbsoluteSize.X * percentage, 0, -2); speedDisplayLabel.Text = tostring(math.floor(speed)) end
            updateSliderFromSpeed(config.currentSpeed)
            local draggingSlider = false
            sliderThumb.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then draggingSlider = true; mainFrame.Draggable = false end end)
            UserInputService.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then if draggingSlider then draggingSlider = false; mainFrame.Draggable = true end end end)
            UserInputService.InputChanged:Connect(function(input) if draggingSlider and input.UserInputType == Enum.UserInputType.MouseMovement then local mouseX = UserInputService:GetMouseLocation().X; local trackStartX = sliderTrack.AbsolutePosition.X; local trackWidth = sliderTrack.AbsoluteSize.X; local relativeX = mouseX - trackStartX; local percentage = math.clamp(relativeX / trackWidth, 0, 1); local newSpeed = MIN_FLIGHT_SPEED + (MAX_FLIGHT_SPEED - MIN_FLIGHT_SPEED) * percentage; config.currentSpeed = newSpeed; updateSliderFromSpeed(newSpeed) end end)
            currentY = currentY + itemHeight + padding - 5
        end
    end
end

local separator2 = Instance.new("Frame"); separator2.Parent = mainFrame
separator2.Size = UDim2.new(1, -20, 0, 2); separator2.Position = UDim2.new(0, 10, 0, currentY)
separator2.BackgroundColor3 = Color3.fromRGB(80,80,80); separator2.BorderSizePixel = 0
currentY = currentY + 2 + padding

local featureStatusY = currentY; local statusLabelHeight = 18
local statusFeatures = {"teleport_mode", "anti_aim", "flight_mode", "third_person", "fake_lag"}
for i, featureId in ipairs(statusFeatures) do
    local config = featuresConfig[featureId]
    if config then
        local statusLabel = Instance.new("TextLabel"); statusLabel.Name = config.id .. "StatusLabel"; statusLabel.Parent = mainFrame
        statusLabel.Size = UDim2.new(1, -20, 0, statusLabelHeight); statusLabel.Position = UDim2.new(0, 10, 0, featureStatusY)
        statusLabel.BackgroundTransparency = 1; statusLabel.Font = Enum.Font.SourceSans; statusLabel.TextSize = 13; statusLabel.TextXAlignment = Enum.TextXAlignment.Left
        config.ui.statusLabel = statusLabel; updateFeatureToggleButton(config)
        featureStatusY = featureStatusY + statusLabelHeight + (padding / 2)
    end
end
currentY = featureStatusY + padding
mainFrame.Size = UDim2.new(0, 350, 0, math.max(480, currentY + 40))

local instructionLabel = Instance.new("TextLabel"); instructionLabel.Name = "InstructionLabel"; instructionLabel.Parent = mainFrame
instructionLabel.Size = UDim2.new(1, -20, 0, 40); instructionLabel.Position = UDim2.new(0, 10, 0, currentY)
instructionLabel.BackgroundTransparency = 1; instructionLabel.TextColor3 = Color3.fromRGB(150, 150, 150); instructionLabel.Font = Enum.Font.SourceSansItalic
instructionLabel.TextSize = 12; instructionLabel.TextWrapped = true
instructionLabel.Text = "按 Esc 取消按鍵綁定。某些功能（如飛行、傳送）會互相排斥。\n飛行模式現在包含穿牆功能。"
print("DEBUG: Control Panel GUI created.")

-- ========== GUI Creation (Visual Cue Dot) ==========
print("DEBUG: Creating Visual Cue GUI...")
local cueGui=Instance.new("ScreenGui"); cueGui.Name="AimbotVisualCueGui"; cueGui.ResetOnSpawn=false; cueGui.IgnoreGuiInset=true; cueGui.ZIndexBehavior=Enum.ZIndexBehavior.Global; cueGui.DisplayOrder=1000; cueGui.Parent=CoreGui
local cueDot=Instance.new("Frame"); cueDot.Name="CueDot"; cueDot.Size=UDim2.fromOffset(DOT_SIZE.X,DOT_SIZE.Y); cueDot.AnchorPoint=Vector2.new(0.5,0.5); cueDot.Position=UDim2.new(0.5,0,0.5,0); cueDot.BackgroundColor3=DOT_COLOR_NOLOCK; cueDot.BorderSizePixel=0; cueDot.Visible=true; cueDot.Parent=cueGui
local dotCorner=Instance.new("UICorner"); dotCorner.CornerRadius=UDim.new(0.5,0); dotCorner.Parent=cueDot
print("DEBUG: Visual Cue GUI created.")

-- ========== Core Logic Functions (Kept similar to your working old version for Solara) ==========
-- Using the more compact getNearestPlayer from your provided old script.
-- This version of getNearestPlayer ALWAYS does a line-of-sight check.
local function getNearestPlayer()
    local closestPlayer=nil; local shortestDistance=math.huge
    local localChar=LocalPlayer.Character
    local localHRP=localChar and localChar:FindFirstChild("HumanoidRootPart")
    if not localChar or not localHRP then return nil end
    for _, player in pairs(Players:GetPlayers()) do
        local char=player.Character
        local hrp=char and char:FindFirstChild("HumanoidRootPart")
        local head=char and char:FindFirstChild("Head") -- Essential for LoS
        local hum=char and char:FindFirstChildOfClass("Humanoid")
        if player~=LocalPlayer and hrp and head and hum and hum.Health>0 then
            local distance=(hrp.Position-localHRP.Position).Magnitude
            if distance<shortestDistance then
                local rayOrigin=Camera.CFrame.Position
                local rayDirection=(head.Position-rayOrigin).Unit*distance -- Ray towards head
                local raycastParams=RaycastParams.new()
                local filterList = {localChar,Camera,controlPanelGui,cueGui}
                if ghostModel and ghostModel.Parent then table.insert(filterList, ghostModel) end
                raycastParams.FilterDescendantsInstances = filterList
                raycastParams.FilterType=Enum.RaycastFilterType.Exclude
                local raycastResult=Workspace:Raycast(rayOrigin,rayDirection,raycastParams)
                if not raycastResult or raycastResult.Instance:IsDescendantOf(char) then
                    shortestDistance=distance; closestPlayer=player
                end
            end
        end
    end
    return closestPlayer
end

local function teleportBehindPlayer(targetPlayer) local localChar=LocalPlayer.Character; local localHRP=localChar and localChar:FindFirstChild("HumanoidRootPart"); local targetChar=targetPlayer.Character; local targetHRP=targetChar and targetChar:FindFirstChild("HumanoidRootPart"); if not localHRP or not targetHRP then return end; local targetPosition=targetHRP.Position; local targetLookVector=targetHRP.CFrame.LookVector; local behindPosition=targetPosition-(targetLookVector.Unit*TELEPORT_BEHIND_DISTANCE); local teleportPos=Vector3.new(behindPosition.X, localHRP.Position.Y, behindPosition.Z); local lookAtPos=Vector3.new(targetPosition.X, teleportPos.Y, targetPosition.Z); pcall(function() localHRP.CFrame=CFrame.new(teleportPos, lookAtPos) end) end
local function teleportRandomlyAroundPlayer(targetPlayer) local localChar=LocalPlayer.Character; local localHRP=localChar and localChar:FindFirstChild("HumanoidRootPart"); local targetChar=targetPlayer.Character; local targetHRP=targetChar and targetChar:FindFirstChild("HumanoidRootPart"); if not localHRP or not targetHRP then return end; local targetPosition=targetHRP.Position; local randomAngle=math.random()*2*math.pi; local randomRadius=math.random()*ANTI_AIM_RADIUS; local offsetX=math.cos(randomAngle)*randomRadius; local offsetZ=math.sin(randomAngle)*randomRadius; local randomPos=Vector3.new(targetPosition.X+offsetX, localHRP.Position.Y, targetPosition.Z+offsetZ); pcall(function() localHRP.CFrame = CFrame.new(randomPos) * (localHRP.CFrame - localHRP.CFrame.Position) end) end

local function createEspForPlayer(player)
    if not DrawingLib then return end -- Check DrawingLib
    if espElements[player] then return end; local elements={};
    elements.Box=DrawingLib.new("Quad"); elements.Box.Color=ESP_BOX_COLOR; elements.Box.Thickness=1; elements.Box.Filled=false; elements.Box.Visible=false;
    elements.Name=DrawingLib.new("Text"); elements.Name.Text=player.Name; elements.Name.Color=ESP_TEXT_COLOR; elements.Name.Size=ESP_TEXT_SIZE; elements.Name.Center=true; elements.Name.Outline=true; elements.Name.Visible=false;
    elements.Health=DrawingLib.new("Text"); elements.Health.Text="100/100"; elements.Health.Color=ESP_TEXT_COLOR; elements.Health.Size=ESP_HEALTH_SIZE; elements.Health.Center=true; elements.Health.Outline=true; elements.Health.Visible=false;
    espElements[player]=elements;
end
local function removeEspForPlayer(player) if espElements[player] then local elements=espElements[player]; if elements.Box then elements.Box:Remove() end; if elements.Name then elements.Name:Remove() end; if elements.Health then elements.Health:Remove() end; espElements[player]=nil end end

setFlightPhysics = function(enabled) local localChar = LocalPlayer.Character; local hrp = localChar and localChar:FindFirstChild("HumanoidRootPart"); if not hrp then return end; if enabled then if not bodyGyro or not bodyGyro.Parent then if bodyGyro then bodyGyro:Destroy() end; bodyGyro = Instance.new("BodyGyro"); bodyGyro.P = 5000; bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9); bodyGyro.CFrame = hrp.CFrame; bodyGyro.Parent = hrp; end; if not bodyVelocity or not bodyVelocity.Parent then if bodyVelocity then bodyVelocity:Destroy() end; bodyVelocity = Instance.new("BodyVelocity"); bodyVelocity.P = 1250; bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9); bodyVelocity.Velocity = Vector3.new(0,0,0); bodyVelocity.Parent = hrp; end else if bodyGyro then bodyGyro:Destroy(); bodyGyro = nil; end; if bodyVelocity then bodyVelocity:Destroy(); bodyVelocity = nil; end end end
restoreCamera = function() Camera.CameraType = originalCameraType; pcall(function() Camera.Focus = originalCameraFocus end); lastThirdPersonPos = nil; end

-- Noclip, Ghost Model, Third Person, Fake Lag logic (from your old script or simplified new one)
setNoclipState = function(enabled) -- From your old script
    local character = LocalPlayer.Character; if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid"); if not humanoid then return end
    if enabled then
        humanoid:ChangeState(Enum.HumanoidStateType.Physics); task.wait()
        for _, part in ipairs(character:GetDescendants()) do if part:IsA("BasePart") then part.CanCollide = false end end
    else
        for _, part in ipairs(character:GetDescendants()) do if part:IsA("BasePart") then part.CanCollide = true end end
        if humanoid:GetState() == Enum.HumanoidStateType.Physics then humanoid:ChangeState(Enum.HumanoidStateType.GettingUp) end
    end
end

destroyGhostModel = function(reason) if ghostModel then pcall(function() ghostModel:Destroy() end); ghostModel = nil end; cframeHistory = {}; lastAppliedDelayedCFrame = nil; end
createOrUpdateGhostModel = function() -- Simplified, ensure it matches your old working version if it was different
    local character = LocalPlayer.Character; if not character then destroyGhostModel("Char nil"); return false end
    local charHRP = character:FindFirstChild("HumanoidRootPart"); if not charHRP then destroyGhostModel("HRP nil"); return false end
    if not ghostModel or not ghostModel.Parent then
        if ghostModel then pcall(function() ghostModel:Destroy() end) end
        ghostModel = Instance.new("Model"); ghostModel.Name = "LocalGhost_"..LocalPlayer.UserId; ghostModel.Archivable = false
        local partsCloned = 0; local ghostHRPCreated = false
        for _, part in ipairs(character:GetChildren()) do
            if part:IsA("BasePart") or part:IsA("MeshPart") then
                local ghostPart = part:Clone(); ghostPart.Name = "Ghost_"..part.Name; ghostPart.Anchored = true; ghostPart.CanCollide = false; ghostPart.CastShadow = false; pcall(function() ghostPart.Transparency = GHOST_TRANSPARENCY end)
                for _, child in ipairs(ghostPart:GetChildren()) do if child:IsA("Decal") or child:IsA("Texture") then child:Destroy() end end
                ghostPart.Parent = ghostModel; partsCloned = partsCloned + 1
                if part.Name == "HumanoidRootPart" then ghostModel.PrimaryPart = ghostPart; ghostHRPCreated = true end
            elseif part:IsA("Accessory") then
                local ghostAccessory = part:Clone(); ghostAccessory.Name = "Ghost_"..part.Name
                if ghostAccessory:FindFirstChild("Handle") and ghostAccessory.Handle:IsA("BasePart") then local h = ghostAccessory.Handle; h.Anchored=true;h.CanCollide=false;pcall(function()h.Transparency=GHOST_TRANSPARENCY end) end
                ghostAccessory.Parent = ghostModel; partsCloned = partsCloned + 1
            end
        end
        if partsCloned > 0 and ghostHRPCreated then ghostModel.Parent = Workspace else destroyGhostModel("Clone fail"); return false end
    end
    if ghostModel and ghostModel.PrimaryPart then pcall(function() ghostModel:SetPrimaryPartCFrame(charHRP.CFrame) end) else destroyGhostModel("SetCF fail"); return false end
    return true
end

local function updateThirdPerson() -- From your old script
    local character=LocalPlayer.Character; local head=character and character:FindFirstChild("Head"); local hrp=character and character:FindFirstChild("HumanoidRootPart"); local anchor=head or hrp; if not anchor then return end
    local anchorPos=anchor.Position; local camCF=Camera.CFrame; local desiredPos=anchorPos + (-camCF.LookVector*THIRD_PERSON_OFFSET.Z) + (camCF.RightVector*THIRD_PERSON_OFFSET.X) + (camCF.UpVector*THIRD_PERSON_OFFSET.Y)
    local ray=Ray.new(anchorPos, (desiredPos-anchorPos).Unit * THIRD_PERSON_OFFSET.Z); local hit,pos=Workspace:FindPartOnRayWithIgnoreList(ray,{character,ghostModel})
    if hit then desiredPos=pos- (desiredPos-anchorPos).Unit*0.5 end
    if not lastThirdPersonPos then lastThirdPersonPos=desiredPos end; lastThirdPersonPos=lastThirdPersonPos:Lerp(desiredPos,1-THIRD_PERSON_SMOOTHING)
    if Camera.CameraType~=Enum.CameraType.Scriptable then Camera.CameraType=Enum.CameraType.Scriptable end
end

local function updateFakeLagLogic() -- From your old script (or simplified new)
    if not featuresConfig.fake_lag.isEnabled then if ghostModel then destroyGhostModel("FL off") end return end
    local char=LocalPlayer.Character; local hrp=char and char:FindFirstChild("HumanoidRootPart")
    if not char or not hrp then destroyGhostModel("No char/hrp FL"); return end
    if hrp.Anchored then hrp.Anchored = false end
    if not createOrUpdateGhostModel() then return end
    local curCF=hrp.CFrame; local curTime=tick(); table.insert(cframeHistory,{t=curTime,cf=curCF})
    local oldestRec,rmIdx=nil,0; for i=1,#cframeHistory do local rec=cframeHistory[i]; if curTime-rec.t>=GHOST_DELAY_SECONDS then oldestRec=rec;rmIdx=i-1 else break end end
    if rmIdx>0 then for i=1,rmIdx do table.remove(cframeHistory,1) end end
    local targetCF=oldestRec and oldestRec.cf
    if targetCF then if not lastAppliedDelayedCFrame or (targetCF.Position-lastAppliedDelayedCFrame.Position).Magnitude>0.01 or (curTime-lastRealCFrameAppliedTime>=MIN_REAL_CFRAME_UPDATE_INTERVAL) then if pcall(function()hrp.CFrame=CFrame.new(targetCF.Position)*(hrp.CFrame-hrp.CFrame.Position)end)then lastRealCFrameAppliedTime=curTime;lastAppliedDelayedCFrame=targetCF end end
    else lastAppliedDelayedCFrame=nil end
    if #cframeHistory>200 then table.remove(cframeHistory,1) end -- Slightly reduced history for Solara
end
print("DEBUG: Core logic functions defined (Solara optimized).")

-- ====================================
-- Main Update Loop (RenderStepped)
-- ====================================
local rsConn
rsConn = RunService.RenderStepped:Connect(function()
    local success, err = pcall(function()
        local localChar = LocalPlayer.Character
        local hrp = localChar and localChar:FindFirstChild("HumanoidRootPart")
        local charHead = localChar and localChar:FindFirstChild("Head")
        if not hrp then return end
        local currentTime = tick()

        if featuresConfig.fake_lag.isEnabled then updateFakeLagLogic() end

        local nearestMovementTarget = nil
        -- For teleport/AA, we might not need strict LoS, use a version of getNearestPlayer that doesn't raycast or pass a flag
        -- For simplicity with Solara, we'll use the single getNearestPlayer that always LoS checks.
        if featuresConfig.teleport_mode.isEnabled or featuresConfig.anti_aim.isEnabled then
            nearestMovementTarget = getNearestPlayer() -- This will do LoS check
        end

        if featuresConfig.flight_mode.isEnabled then
            local moveVector = Vector3.new(0,0,0)
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVector=moveVector+Vector3.new(0,0,-1) end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVector=moveVector+Vector3.new(0,0,1) end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVector=moveVector+Vector3.new(-1,0,0) end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVector=moveVector+Vector3.new(1,0,0) end
            local verticalVelocityValue = 0
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then verticalVelocityValue=FLIGHT_VERTICAL_SPEED end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then verticalVelocityValue=-FLIGHT_VERTICAL_SPEED end
            local calculatedWorldVelocity; local horizontalDirection=(Camera.CFrame*CFrame.new(moveVector)).Position-Camera.CFrame.Position; local horizontalSpeedComponent=Vector3.new(0,0,0)
            if horizontalDirection.Magnitude>0.001 then horizontalSpeedComponent=Vector3.new(horizontalDirection.X,0,horizontalDirection.Z).Unit*featuresConfig.flight_mode.currentSpeed end
            calculatedWorldVelocity=horizontalSpeedComponent+Vector3.new(0,verticalVelocityValue,0)
            if bodyVelocity then bodyVelocity.Velocity = calculatedWorldVelocity end
            if bodyGyro then bodyGyro.CFrame = Camera.CFrame end
        elseif featuresConfig.anti_aim.isEnabled and nearestMovementTarget then teleportRandomlyAroundPlayer(nearestMovementTarget)
        elseif featuresConfig.teleport_mode.isEnabled and nearestMovementTarget then teleportBehindPlayer(nearestMovementTarget)
        end

        if featuresConfig.third_person.isEnabled then updateThirdPerson()
        elseif Camera.CameraType == Enum.CameraType.Scriptable and not featuresConfig.aimbot_module.isEnabled then if restoreCamera then restoreCamera() end end

        local isAiming = false
        if featuresConfig.aimbot_hold.currentKey then
            if featuresConfig.aimbot_hold.currentKey:IsA("UserInputType") then isAiming = UserInputService:IsMouseButtonPressed(featuresConfig.aimbot_hold.currentKey)
            elseif featuresConfig.aimbot_hold.currentKey:IsA("KeyCode") then isAiming = UserInputService:IsKeyDown(featuresConfig.aimbot_hold.currentKey) end
        end

        local aimbotTargetPlayer = nil
        if featuresConfig.aimbot_module.isEnabled and isAiming then
            aimbotTargetPlayer = getNearestPlayer() -- Always LoS check
        end

        local isLocked = false; local newCameraCFrame = nil
        if aimbotTargetPlayer then
            local targetHead = aimbotTargetPlayer.Character and aimbotTargetPlayer.Character:FindFirstChild("Head")
            if targetHead then
                isLocked = true
                if featuresConfig.third_person.isEnabled then
                    if charHead and lastThirdPersonPos then newCameraCFrame = CFrame.new(lastThirdPersonPos, lastThirdPersonPos + (targetHead.Position - charHead.Position).Unit)
                    else isLocked = false end
                else newCameraCFrame = CFrame.new(Camera.CFrame.Position, targetHead.Position) end
            end
        end

        if isLocked and newCameraCFrame then pcall(function() Camera.CFrame = newCameraCFrame end)
        elseif featuresConfig.third_person.isEnabled and lastThirdPersonPos then
             local lookAtPos = (charHead or hrp).Position; pcall(function() Camera.CFrame = CFrame.new(lastThirdPersonPos, lookAtPos) end)
        elseif not featuresConfig.third_person.isEnabled and Camera.CameraType == Enum.CameraType.Scriptable and not (featuresConfig.aimbot_module.isEnabled and isAiming) then
            if restoreCamera then restoreCamera() end
        end

        cueDot.BackgroundColor3 = isLocked and DOT_COLOR_LOCKED or DOT_COLOR_NOLOCK

        local shouldBeShooting = isLocked
        if shouldBeShooting then
            if currentTime - lastClickTime >= TRIGGERBOT_CLICK_INTERVAL then
                if typeof(mouse1press) == "function" then pcall(mouse1press) end
                if typeof(mouse1release) == "function" then task.defer(mouse1release) end
                lastClickTime = currentTime
            end
        elseif lastShootingState and not shouldBeShooting then if typeof(mouse1release) == "function" then pcall(mouse1release) end end
        lastShootingState = shouldBeShooting

        if featuresConfig.esp_module.isEnabled and DrawingLib then
             for _, player in pairs(Players:GetPlayers()) do if player==LocalPlayer then continue end; local char=player.Character; local hum=char and char:FindFirstChildOfClass("Humanoid"); local hrpEsp=char and char:FindFirstChild("HumanoidRootPart"); local headEsp=char and char:FindFirstChild("Head"); if hum and hrpEsp and headEsp and hum.Health>0 then if not espElements[player] then createEspForPlayer(player) end; local elements=espElements[player]; if not elements then continue end; local headPos,headVis=Camera:WorldToViewportPoint(headEsp.Position+Vector3.new(0,0.5,0)); local hrpPos,hrpVis=Camera:WorldToViewportPoint(hrpEsp.Position); if headVis and hrpVis then local boxH=math.abs(headPos.Y-hrpPos.Y); local boxW=boxH/2; local tl=Vector2.new(headPos.X-boxW/2,headPos.Y); elements.Box.PointA=tl; elements.Box.PointB=Vector2.new(tl.X+boxW,tl.Y); elements.Box.PointC=Vector2.new(tl.X+boxW,hrpPos.Y); elements.Box.PointD=Vector2.new(tl.X,hrpPos.Y); elements.Box.Visible=true; elements.Name.Position=Vector2.new(headPos.X,headPos.Y-ESP_TEXT_SIZE-2); elements.Name.Visible=true; local healthT=math.floor(hum.Health).."/"..math.floor(hum.MaxHealth); elements.Health.Text=healthT; elements.Health.Position=Vector2.new(hrpPos.X,hrpPos.Y+2); elements.Health.Visible=true else elements.Box.Visible=false; elements.Name.Visible=false; elements.Health.Visible=false end else if espElements[player] then local e=espElements[player]; e.Box.Visible=false; e.Name.Visible=false; e.Health.Visible=false end end end
        else
            if next(espElements) then for _, es in pairs(espElements) do if es.Box then es.Box.Visible=false end; if es.Name then es.Name.Visible=false end; if es.Health then es.Health.Visible=false end end end
        end
    end)
    if not success then warn("DEBUG: ERROR in RenderStepped:", err, debug.traceback(err)) end
end)
print("DEBUG: RenderStepped connected.")

-- ========== Player Added/Removed Handlers ==========
print("DEBUG: Connecting Player Handlers (ESP)...")
Players.PlayerAdded:Connect(function(player) if DrawingLib then createEspForPlayer(player) end end)
Players.PlayerRemoving:Connect(removeEspForPlayer)
if DrawingLib then for _, player in pairs(Players:GetPlayers()) do if player ~= LocalPlayer then createEspForPlayer(player) end end end
print("DEBUG: Initial players processed for ESP.")

-- ========== Character Added/Removed Handlers (Fake Lag & Noclip Refresh) ==========
print("DEBUG: Connecting Character Handlers (FakeLag & Noclip)...")
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    if destroyGhostModel then destroyGhostModel("New char") end
    if featuresConfig.fake_lag.isEnabled and LocalPlayer.Character == newCharacter then task.wait(0.1); if createOrUpdateGhostModel then createOrUpdateGhostModel() end end
    if featuresConfig.flight_mode.isEnabled then task.wait(0.2); if setNoclipState then setNoclipState(true) end; if setFlightPhysics then setFlightPhysics(true) end end
end)
LocalPlayer.CharacterRemoving:Connect(function(oldCharacter)
    if destroyGhostModel then destroyGhostModel("Char removed") end
    if featuresConfig.flight_mode.isEnabled and setFlightPhysics then setFlightPhysics(false) end
end)
print("DEBUG: Character Handlers (FakeLag & Noclip) connected.")

-- ========== Input Handling ==========
print("DEBUG: Connecting Input Handling...")
local inputConn
inputConn = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if currentlyBindingFeature then
        if input.KeyCode == CANCEL_BIND_KEY then resetButtonStates(); return end
        local conf = featuresConfig[currentlyBindingFeature]; if not conf then resetButtonStates(); return end
        local newKeyCand = nil; local isRes = false
        if input.UserInputType == Enum.UserInputType.Keyboard then newKeyCand=input.KeyCode; local k=input.KeyCode; if k==Enum.KeyCode.LeftShift or k==Enum.KeyCode.RightShift or k==Enum.KeyCode.LeftControl or k==Enum.KeyCode.RightControl or k==Enum.KeyCode.Tab or k==CANCEL_BIND_KEY then isRes=true end
        elseif input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.MouseButton2 or input.UserInputType==Enum.UserInputType.MouseButton3 then newKeyCand=input.UserInputType
        else resetButtonStates(); return end
        if not isRes and newKeyCand then for id,c in pairs(featuresConfig)do if id~=currentlyBindingFeature and c.currentKey==newKeyCand then isRes=true;break end end end
        if isRes then return end
        if newKeyCand then conf.currentKey=newKeyCand; if updateFeatureKeyDisplay then updateFeatureKeyDisplay(conf) end end
        resetButtonStates(); return
    end
    if gameProcessedEvent and not (mainFrame and mainFrame.Visible and mainFrame.Active) then return end
    for fid, cfg in pairs(featuresConfig) do
        if cfg.currentKey and ((input.UserInputType==Enum.UserInputType.Keyboard and input.KeyCode==cfg.currentKey)or(input.UserInputType~=Enum.UserInputType.Keyboard and input.UserInputType==cfg.currentKey)) then
            if gameProcessedEvent and fid~="gui_toggle" and not (cfg.id=="aimbot_hold" and input.UserInputType:IsA("UserInputType") and UserInputService:IsMouseButtonPressed(cfg.currentKey)) then if not(cfg.id=="aimbot_hold" and (cfg.currentKey==Enum.UserInputType.MouseButton1 or cfg.currentKey==Enum.UserInputType.MouseButton2 or cfg.currentKey==Enum.UserInputType.MouseButton3))then return end end
            if fid=="gui_toggle" then cfg.isEnabled=not cfg.isEnabled; if mainFrame then mainFrame.Visible=cfg.isEnabled end; UserInputService.MouseIconEnabled=cfg.isEnabled
            else cfg.isEnabled=not cfg.isEnabled; if updateFeatureToggleButton then updateFeatureToggleButton(cfg) end; if cfg.onToggle then pcall(cfg.onToggle,cfg,cfg.isEnabled)end end
            return
        end
    end
end)
print("DEBUG: Input Handling connected.")

-- ========== Initialization ==========
if mainFrame then mainFrame.Visible = featuresConfig.gui_toggle.isEnabled end
UserInputService.MouseIconEnabled = featuresConfig.gui_toggle.isEnabled
if featuresConfig.gui_toggle.isEnabled then UserInputService.MouseBehavior = Enum.MouseBehavior.Default end

-- Cleanup function
local function cleanup()
    print("DEBUG: Script cleanup initiated (Solara)...")
    if rsConn then rsConn:Disconnect(); rsConn=nil end
    if inputConn then inputConn:Disconnect(); inputConn=nil end
    -- No slider event connections stored in this simplified version to disconnect
    if setFlightPhysics then setFlightPhysics(false) end
    if setNoclipState then setNoclipState(false) end
    if destroyGhostModel then destroyGhostModel("Script cleanup") end
    for player, _ in pairs(espElements) do removeEspForPlayer(player) end
    if controlPanelGui and controlPanelGui.Parent then controlPanelGui:Destroy() end
    if cueGui and cueGui.Parent then cueGui:Destroy() end
    if featuresConfig.third_person.isEnabled and restoreCamera then pcall(restoreCamera) end
    UserInputService.MouseIconEnabled = true
    print("DEBUG: Cleanup complete (Solara).")
end

if script and typeof(script) == "Instance" then
    script.Destroying:Connect(cleanup)
end
print("DEBUG: Script fully loaded and initialized (Solara version).")
