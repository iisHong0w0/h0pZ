-- 看三小
--
--                                         ,s555SB@@&                          
--                                     :9H####@@@@@Xi                        
--                                     1@@@@@@@@@@@@@@8                       
--                                   ,8@@@@@@@@@B@@@@@@8                      
--                                  :B@@@@X3hi8Bs;B@@@@@Ah,                   
--             ,8i                  r@@@B:     1S ,M@@@@@@#8;                 
--            1AB35.i:               X@@8 .   SGhr ,A@@@@@@@@S                
--            1@h31MX8                18Hhh3i .i3r ,A@@@@@@@@@5               
--            ;@&i,58r5                 rGSS:     :B@@@@@@@@@@A               
--             1#i  . 9i                 hX.  .: .5@@@@@@@@@@@1               
--              sG1,  ,G53s.              9#Xi;hS5 3B@@@@@@@B1                
--               .h8h.,A@@@MXSs,           #@H1:    3ssSSX@1                  
--               s ,@@@@@@@@@@@@Xhi,       r#@@X1s9M8    .GA981               
--               ,. rS8H#@@@@@@@@@@#HG51;.  .h31i;9@r    .8@@@@BS;i;          
--                .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS        
--                s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&,      
--              :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B,     
--            .hM@@@#@@#MX 51  r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8     
--          :3B@@@@@@@@@@@&9@h :Gs   .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:    
--      s&HA#@@@@@@@@@@@@@@M89A;.8S.       ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r    
--   ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;.         ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i    
--  5#@@#&@@@@@@@@@@@@@@@@@@9  .39:          ;@@@@@@@@@@@@@@@@@@@@@@@@@@@;    
--  9@@@X:MM@@@@@@@@@@@@@@@#;    ;31.         H@@@@@@@@@@@@@@@@@@@@@@@@@@:    
--   SH#@B9.rM@@@@@@@@@@@@@B       :.         3@@@@@@@@@@@@@@@@@@@@@@@@@@5    
--     ,:.   9@@@@@@@@@@@#HB5                 .M@@@@@@@@@@@@@@@@@@@@@@@@@B    
--           ,ssirhSM@&1;i19911i,.             s@@@@@@@@@@@@@@@@@@@@@@@@@@S   
--              ,,,rHAri1h1rh&@#353Sh:          8@@@@@@@@@@@@@@@@@@@@@@@@@#:  
--            .A3hH@#5S553&@@#h   i:i9S          #@@@@@@@@@@@@@@@@@@@@@@@@@A. 
--
--
--    又看源码，看你妹妹呀！
--
-- 看三小

-- ========== Roblox Services ==========
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")
print("DEBUG: Services loaded.")

-- ========== Drawing Library Check (CRUCIAL FOR ESP) ==========
local DrawingLib = nil
if typeof(Drawing) == "table" and typeof(Drawing.new) == "function" then
    DrawingLib = Drawing
    print("DEBUG: Drawing library found and seems valid.")
else
    warn("DEBUG: WARNING - 'Drawing' library not found or invalid. ESP will be disabled.")
end

-- ========== Player & Camera ==========
local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then warn("DEBUG: FATAL - LocalPlayer not found!") return end
print("DEBUG: LocalPlayer found:", LocalPlayer.Name)
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
if not PlayerGui then warn("DEBUG: FATAL - PlayerGui not found after wait!") return end
print("DEBUG: PlayerGui loaded.")
local Camera = Workspace.CurrentCamera
if not Camera then warn("DEBUG: FATAL - Workspace.CurrentCamera not found!") return end
print("DEBUG: Camera found.")

-- ========== Initial Default Configuration ==========
local DEFAULT_AIMBOT_HOLD_KEY_INIT = Enum.UserInputType.MouseButton2
local TOGGLE_GUI_KEY_INIT = Enum.KeyCode.Insert
local CANCEL_BIND_KEY = Enum.KeyCode.Escape
local TELEPORT_KEY_INIT = Enum.KeyCode.H
local ANTI_AIM_KEY_INIT = Enum.KeyCode.N
local FLIGHT_TOGGLE_KEY_INIT = Enum.KeyCode.V
local THIRD_PERSON_TOGGLE_KEY_INIT = Enum.KeyCode.T
local FAKE_LAG_TOGGLE_KEY_INIT = Enum.KeyCode.X
local BHOP_TOGGLE_KEY_INIT = Enum.KeyCode.LeftAlt
local ACTIVE_FEATURES_GUI_TOGGLE_KEY_INIT = Enum.KeyCode.Delete

local TELEPORT_BEHIND_DISTANCE_INIT = 3
local MIN_TELEPORT_BEHIND_DISTANCE = 1
local MAX_TELEPORT_BEHIND_DISTANCE = 10

local ANTI_AIM_RADIUS_INIT = 5
local MIN_ANTI_AIM_RADIUS = 2
local MAX_ANTI_AIM_RADIUS = 15

local INITIAL_FLIGHT_SPEED = 50
local MIN_FLIGHT_SPEED = 10
local MAX_FLIGHT_SPEED = 200
local FLIGHT_VERTICAL_SPEED = 30

local TRIGGERBOT_CLICK_INTERVAL_MS_INIT = 0
local MIN_TRIGGERBOT_DELAY_MS = 0
local MAX_TRIGGERBOT_DELAY_MS = 5000

local DEFAULT_AIR_STRAFE_FORCE = 1234
local MIN_AIR_STRAFE_FORCE = 100
local MAX_AIR_STRAFE_FORCE = 5000
local MAX_BHOP_AIR_SPEED = 70

local DOT_COLOR_NOLOCK=Color3.fromRGB(220,220,220); local DOT_COLOR_LOCKED=Color3.fromRGB(200,0,0); local DOT_SIZE=Vector2.new(4,4) -- Adjusted for new theme
local ESP_BOX_COLOR=Color3.fromRGB(200,0,0); local ESP_TEXT_COLOR=Color3.fromRGB(220,220,220); local ESP_TEXT_SIZE=14; local ESP_HEALTH_SIZE=12 -- Adjusted for new theme

local THIRD_PERSON_OFFSET_XY = Vector2.new(1.5, 2)
local DEFAULT_THIRD_PERSON_DISTANCE_Z = 8
local MIN_THIRD_PERSON_DISTANCE_Z = 2
local MAX_THIRD_PERSON_DISTANCE_Z = 30
local THIRD_PERSON_SMOOTHING = 0.1

local GHOST_DELAY_SECONDS = 1
local GHOST_TRANSPARENCY = 0.5
local MIN_REAL_CFRAME_UPDATE_INTERVAL = 0.5

-- Hitmarker Configuration
local HITMARKER_CHECK_INTERVAL = 0.1 -- Seconds between health checks
local HITMARKER_DURATION = 0.3 -- Seconds the hitmarker stays visible
local HITMARKER_TEXT = "X"
local DEFAULT_HITMARKER_SIZE = 30
local MIN_HITMARKER_SIZE = 10
local MAX_HITMARKER_SIZE = 100
local HITMARKER_COLOR = Color3.fromRGB(255, 255, 255) -- White (Effective against dark themes)
local HITMARKER_OUTLINE_COLOR = Color3.fromRGB(0, 0, 0) -- Black Outline

print("DEBUG: Initial default configurations set.")

-- ========== State Variables ==========
local espElements = {}
local lastClickTime = 0
local bodyVelocity = nil
local bodyGyro = nil
local originalCameraType = Camera.CameraType
local originalCameraFocus = Camera.Focus
local lastThirdPersonPos = nil
local ghostModel = nil
local cframeHistory = {}
local lastRealCFrameAppliedTime = 0
local lastAppliedDelayedCFrame = nil
local currentlyBindingFeature = nil
local originalHumanoidState = nil
local isBhopJumping = false
local canBhopAirStrafe = false
local bhopStateChangedConnection = nil
local activeFeaturesGuiVisible = true
local wasTryingToShootLastFrame = false

-- Hitmarker State
local lastCheckedHealth = {} -- [Player] = health
local hitmarkerVisibleUntil = 0 -- Timestamp (tick())
local currentHitTarget = nil -- Stores the Player instance of the current hit target for tracking
local lastHealthCheckTime = 0 -- For timing health checks

-- Friendly Player State
local friendlyPlayersState = {} -- [PlayerInstance] = true (if friendly)

print("DEBUG: Core state variables initialized.")

-- Forward declaration
local setFlightPhysics, destroyGhostModel, createOrUpdateGhostModel, restoreCamera, updateFeatureToggleButton, updateFeatureKeyDisplay, setNoclipState
local onBhopJumpRequest, onBhopHumanoidStateChanged, connectBhopStateChanged, disconnectBhopStateChanged
local updateActiveFeaturesDisplay, updateFriendlyPlayersDisplay
local getNearestPlayerAbsolute, getNearestVisiblePlayer
local findNearestEnemy -- Added for Hitmarker

-- General Sound Function (Used by other features)
local function playSound(soundId, volume, pitch)
    pitch = pitch or 1 -- Default pitch if not provided
    local sound = Instance.new("Sound"); sound.SoundId = soundId; sound.Volume = volume; sound.Pitch = pitch
    sound.Parent = SoundService; sound:Play(); sound.Ended:Connect(function() sound:Destroy() end)
end

-- ========== Features Configuration & State Management Table ==========
featuresConfig = {
    aimbot_module = { id = "aimbot_module", displayName = "自動瞄準模組", category = "瞄準", isEnabled = true, ui = {}, showInActiveList = true },
    triggerbot_module = {
        id = "triggerbot_module", displayName = "自動開槍", category = "瞄準", isEnabled = true,
        currentDelayMs = TRIGGERBOT_CLICK_INTERVAL_MS_INIT, ui = {}, showInActiveList = true,
        onToggle = function(self, enabled)
            if updateActiveFeaturesDisplay then updateActiveFeaturesDisplay() end
            playSound("rbxassetid://1309223513", enabled and 0.4 or 0.2, enabled and 1.5 or 0.8)
        end
    },
    esp_module = {
        id = "esp_module", displayName = "ESP透視模組", category = "透視", isEnabled = DrawingLib ~= nil, ui = {}, showInActiveList = true,
        onToggle = function(self, enabled)
            if not DrawingLib then if self.ui.toggleButton then self.isEnabled = false; if updateFeatureToggleButton then updateFeatureToggleButton(self) end end; return end
            if not enabled then for _, els in pairs(espElements) do if els.Box then els.Box.Visible = false end; if els.Name then els.Name.Visible = false end; if els.Health then els.Health.Visible = false end end end
            if updateActiveFeaturesDisplay then updateActiveFeaturesDisplay() end
        end
    },
    aimbot_hold = { id = "aimbot_hold", displayName = "按住瞄準鍵", category = "瞄準", currentKey = DEFAULT_AIMBOT_HOLD_KEY_INIT, ui = {} },
    teleport_mode = {
        id = "teleport_mode", displayName = "傳送至背後", category = "移動", isEnabled = false, currentKey = TELEPORT_KEY_INIT,
        currentTeleportDistance = TELEPORT_BEHIND_DISTANCE_INIT, ui = {}, showInActiveList = true,
        onToggle = function(self, enabled)
            if enabled then for _, fid in ipairs({"anti_aim", "flight_mode", "fake_lag", "bhop_mode"}) do local cfg = featuresConfig[fid]; if cfg.isEnabled then cfg.isEnabled = false; if cfg.ui.toggleButton then updateFeatureToggleButton(cfg) end; if cfg.onToggle then cfg.onToggle(cfg, false) end end end end
            playSound("rbxassetid://9111384194", 0.5, enabled and 1 or 0.8)
            if updateActiveFeaturesDisplay then updateActiveFeaturesDisplay() end
        end
    },
    anti_aim = {
        id = "anti_aim", displayName = "隨機傳送 (舊AA)", category = "移動", isEnabled = false, currentKey = ANTI_AIM_KEY_INIT,
        currentAntiAimRadius = ANTI_AIM_RADIUS_INIT, ui = {}, showInActiveList = true,
        onToggle = function(self, enabled)
            if enabled then for _, fid in ipairs({"teleport_mode", "flight_mode", "fake_lag", "bhop_mode"}) do local cfg = featuresConfig[fid]; if cfg.isEnabled then cfg.isEnabled = false; if cfg.ui.toggleButton then updateFeatureToggleButton(cfg) end; if cfg.onToggle then cfg.onToggle(cfg, false) end end end end
            playSound("rbxassetid://9111384194", 0.6, enabled and 1.2 or 0.7)
            if updateActiveFeaturesDisplay then updateActiveFeaturesDisplay() end
        end
    },
    flight_mode = {
        id = "flight_mode", displayName = "飛行模式", category = "移動", isEnabled = false, currentKey = FLIGHT_TOGGLE_KEY_INIT, currentSpeed = INITIAL_FLIGHT_SPEED, ui = {}, showInActiveList = true,
        onToggle = function(self, enabled)
            if setFlightPhysics then setFlightPhysics(enabled) end; if setNoclipState then setNoclipState(enabled) end
            if enabled then for _, fid in ipairs({"teleport_mode", "anti_aim", "fake_lag", "bhop_mode"}) do local cfg = featuresConfig[fid]; if cfg.isEnabled then cfg.isEnabled = false; if cfg.ui.toggleButton then updateFeatureToggleButton(cfg) end; if cfg.onToggle then cfg.onToggle(cfg, false) end end end end
            playSound("rbxassetid://9111384194", 0.6, enabled and 1.4 or 0.6)
            if updateActiveFeaturesDisplay then updateActiveFeaturesDisplay() end
        end
    },
    bhop_mode = {
        id = "bhop_mode", displayName = "連跳模式 (Bhop)", category = "移動", isEnabled = false, currentKey = BHOP_TOGGLE_KEY_INIT, currentAirStrafeForce = DEFAULT_AIR_STRAFE_FORCE, ui = {}, showInActiveList = true,
        onToggle = function(self, enabled)
            if enabled then for _, fid in ipairs({"teleport_mode", "anti_aim", "flight_mode", "fake_lag"}) do local cfg = featuresConfig[fid]; if cfg.isEnabled then cfg.isEnabled = false; if cfg.ui.toggleButton then updateFeatureToggleButton(cfg) end; if cfg.onToggle then cfg.onToggle(cfg, false) end end end; if connectBhopStateChanged then connectBhopStateChanged() end
            else if disconnectBhopStateChanged then disconnectBhopStateChanged() end end
            playSound("rbxassetid://1309223513", 0.5, enabled and 1.1 or 0.9)
            if updateActiveFeaturesDisplay then updateActiveFeaturesDisplay() end
        end
    },
    third_person = {
        id = "third_person", displayName = "第三人稱", category = "雜項", isEnabled = false, currentKey = THIRD_PERSON_TOGGLE_KEY_INIT, currentDistanceZ = DEFAULT_THIRD_PERSON_DISTANCE_Z, ui = {}, showInActiveList = true,
        onToggle = function(self, enabled)
            if enabled then originalCameraType = Camera.CameraType; originalCameraFocus = Camera.Focus; Camera.CameraType = Enum.CameraType.Scriptable; lastThirdPersonPos = nil
            else if restoreCamera then restoreCamera() end end
            if updateActiveFeaturesDisplay then updateActiveFeaturesDisplay() end
        end
    },
     hitmarker = {
        id = "hitmarker", displayName = "命中標記", category = "雜項", isEnabled = true,
        currentHitmarkerSize = DEFAULT_HITMARKER_SIZE,
        ui = {}, showInActiveList = true,
        onToggle = function(self, enabled)
             local hmLabel = hitmarkerScreenGui and hitmarkerScreenGui:FindFirstChild("HitmarkerX")
             if not enabled and hmLabel then
                 hmLabel.Visible = false
                 currentHitTarget = nil
             end
             if updateActiveFeaturesDisplay then updateActiveFeaturesDisplay() end
        end
    },
    fake_lag = {
        id = "fake_lag", displayName = "延遲假身", category = "移動", isEnabled = false, currentKey = FAKE_LAG_TOGGLE_KEY_INIT, ui = {}, showInActiveList = true,
        onToggle = function(self, enabled)
            if enabled then for _, fid in ipairs({"teleport_mode", "anti_aim", "flight_mode", "bhop_mode"}) do local cfg = featuresConfig[fid]; if cfg.isEnabled then cfg.isEnabled = false; if cfg.ui.toggleButton then updateFeatureToggleButton(cfg) end; if cfg.onToggle then cfg.onToggle(cfg, false) end end end; lastRealCFrameAppliedTime = 0; lastAppliedDelayedCFrame = nil; cframeHistory = {}; if LocalPlayer.Character and createOrUpdateGhostModel then createOrUpdateGhostModel() end
            else if destroyGhostModel then destroyGhostModel("FakeLag toggled OFF") end end
            playSound("rbxassetid://9111384194", 0.6, enabled and 1.5 or 0.5)
            if updateActiveFeaturesDisplay then updateActiveFeaturesDisplay() end
        end
    },
    friendly_players_list = {
        id = "friendly_players_list",
        displayName = "友軍勾選單",
        category = "設定",
        ui = {},
        showInActiveList = false
    },
    gui_toggle = { id = "gui_toggle", displayName = "開關主介面", category = "設定", isEnabled = true, currentKey = TOGGLE_GUI_KEY_INIT, ui = {}, onToggle = function() if updateActiveFeaturesDisplay then updateActiveFeaturesDisplay() end end },
    active_features_gui_toggle = { id = "active_features_gui_toggle", displayName = "開關啟用列表", category = "設定", isEnabled = true, currentKey = ACTIVE_FEATURES_GUI_TOGGLE_KEY_INIT, ui = {} }
}
print("DEBUG: featuresConfig initialized with hitmarker and friendly_players_list.")

if not DrawingLib and featuresConfig.esp_module.isEnabled then featuresConfig.esp_module.isEnabled = false end

-- ========== Helper Functions ==========
function getKeyName(inputObject)
    if not inputObject then return "無" end
    local s, n = pcall(function() if inputObject:IsA("KeyCode") then return inputObject.Name elseif inputObject:IsA("UserInputType") then if inputObject == Enum.UserInputType.MouseButton1 then return "左鍵" elseif inputObject == Enum.UserInputType.MouseButton2 then return "右鍵" elseif inputObject == Enum.UserInputType.MouseButton3 then return "中鍵" else return inputObject.Name end end; return "未知" end)
    return s and n or "錯誤"
end

local theme = { -- MODIFIED: Red/Black Aimware-like Theme
    Background = Color3.fromRGB(15, 15, 15),          -- Near Black
    LighterBackground = Color3.fromRGB(25, 25, 25),     -- Dark Grey
    ElementBackground = Color3.fromRGB(35, 35, 35),     -- Slightly Lighter Dark Grey
    Accent = Color3.fromRGB(200, 0, 0),               -- Strong Red
    TextPrimary = Color3.fromRGB(220, 220, 220),       -- Light Grey / Off-White
    TextSecondary = Color3.fromRGB(150, 150, 150),     -- Medium Grey
    Border = Color3.fromRGB(50,0,0), --Color3.fromRGB(5, 5, 5),                -- Very Dark Grey / Near Black or Dark Red
    Success = Color3.fromRGB(0, 180, 0),               -- Distinct Green
    Failure = Color3.fromRGB(200, 0, 0),               -- Strong Red (Same as Accent)
    KeybindText = Color3.fromRGB(200, 0, 0),           -- Accent Red
    ActiveListText = Color3.fromRGB(200, 0, 0),        -- Accent Red
    CheckboxChecked = Color3.fromRGB(200, 0, 0),       -- Accent Red
    CheckboxUnchecked = Color3.fromRGB(100, 100, 100), -- Darker Grey for unchecked
    SearchBoxPlaceholder = Color3.fromRGB(100, 100, 100)-- Darker Grey
}


updateFeatureToggleButton = function(featureConfig)
    if featureConfig and featureConfig.ui and featureConfig.ui.toggleButton then
        local btn = featureConfig.ui.toggleButton
        if featureConfig.isEnabled then
            btn.Text = featureConfig.displayName; btn.TextColor3 = theme.TextPrimary -- Use TextPrimary for enabled text on dark buttons
            btn.BackgroundColor3 = theme.Accent -- Use Accent for background of enabled toggle
            btn.BorderSizePixel = 1; btn.BorderColor3 = theme.Border -- theme.Accent or a darker shade of it
        else
            btn.Text = featureConfig.displayName; btn.TextColor3 = theme.TextSecondary
            btn.BackgroundColor3 = theme.ElementBackground; btn.BorderSizePixel = 1; btn.BorderColor3 = theme.Border
        end
         if featureConfig.id == "gui_toggle" or featureConfig.id == "active_features_gui_toggle" then
             btn.Text = (featureConfig.isEnabled and "[ON] " or "[OFF] ") .. featureConfig.displayName
             btn.BorderColor3 = featureConfig.isEnabled and theme.Success or theme.Failure
             btn.BackgroundColor3 = theme.ElementBackground -- Keep consistent for these specific toggles
             btn.TextColor3 = featureConfig.isEnabled and theme.Success or theme.Failure
         end
    end
end

updateFeatureKeyDisplay = function(featureConfig)
    if featureConfig and featureConfig.ui and featureConfig.ui.keyDisplayLabel then
        featureConfig.ui.keyDisplayLabel.Text = getKeyName(featureConfig.currentKey)
        featureConfig.ui.keyDisplayLabel.TextColor3 = theme.KeybindText -- Ensure keybind text uses the theme
    end
end

resetButtonStates = function()
    if currentlyBindingFeature then
        local config = featuresConfig[currentlyBindingFeature]
        if config and config.ui and config.ui.changeKeyButton then
            config.ui.changeKeyButton.Text = "綁定"; config.ui.changeKeyButton.BackgroundColor3 = theme.ElementBackground -- Use ElementBackground for reset
            config.ui.changeKeyButton.BorderColor3 = theme.Border
            config.ui.changeKeyButton.TextColor3 = theme.TextPrimary
        end
    end
    currentlyBindingFeature = nil
end

-- ========== New GUI Creation (CS2 Inspired) ==========
print("DEBUG: Creating NiggaLOSE v7.0 Panel GUI...") -- MODIFIED
local controlPanelGui = Instance.new("ScreenGui")
controlPanelGui.Name = "NiggaLOSE_v7_Main"; controlPanelGui.ResetOnSpawn = false; controlPanelGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
controlPanelGui.Parent = PlayerGui

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"; mainFrame.Size = UDim2.new(0, 550, 0, 420)
mainFrame.Position = UDim2.new(0.5, -mainFrame.Size.X.Offset / 2, 0.5, -mainFrame.Size.Y.Offset / 2)
mainFrame.BackgroundColor3 = theme.Background; mainFrame.BorderSizePixel = 1; mainFrame.BorderColor3 = theme.Border
mainFrame.Active = true; mainFrame.Draggable = true; mainFrame.Parent = controlPanelGui; mainFrame.Visible = featuresConfig.gui_toggle.isEnabled

local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"; titleBar.Parent = mainFrame; titleBar.Size = UDim2.new(1, 0, 0, 30)
titleBar.BackgroundColor3 = theme.Accent; -- MODIFIED: Title bar with Accent color
titleBar.BorderSizePixel = 0

local logoAssetId = "rbxassetid://124006968336886"; local logoSize = 24; local titleBarPadding = 5
local logoLeft = Instance.new("ImageLabel")
logoLeft.Name = "LogoLeft"; logoLeft.Parent = titleBar; logoLeft.Size = UDim2.new(0, logoSize, 0, logoSize); logoLeft.Position = UDim2.new(0, titleBarPadding, 0.5, -logoSize/2)
logoLeft.Image = logoAssetId; logoLeft.BackgroundTransparency = 1; logoLeft.ScaleType = Enum.ScaleType.Fit
logoLeft.ImageColor3 = theme.TextPrimary -- Make logo visible on red bar

local logoRight = Instance.new("ImageLabel")
logoRight.Name = "LogoRight"; logoRight.Parent = titleBar; logoRight.Size = UDim2.new(0, logoSize, 0, logoSize); logoRight.Position = UDim2.new(1, -(logoSize + titleBarPadding), 0.5, -logoSize/2)
logoRight.Image = logoAssetId; logoRight.BackgroundTransparency = 1; logoRight.ScaleType = Enum.ScaleType.Fit
logoRight.ImageColor3 = theme.TextPrimary -- Make logo visible on red bar

local websiteLabel = Instance.new("TextLabel")
websiteLabel.Name = "WebsiteLabel"; websiteLabel.Parent = titleBar; local websiteLabelWidth = 160
websiteLabel.Size = UDim2.new(0, websiteLabelWidth, 0, 12); websiteLabel.Position = UDim2.new(1, -(logoSize + titleBarPadding + websiteLabelWidth + titleBarPadding), 0.5, -6)
websiteLabel.Text = "iishong0w0.github.io/niggalose"; websiteLabel.Font = Enum.Font.SourceSansLight; websiteLabel.TextSize = 10; websiteLabel.TextColor3 = theme.TextPrimary -- Adjusted for visibility on red
websiteLabel.TextXAlignment = Enum.TextXAlignment.Right; websiteLabel.BackgroundTransparency = 1

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"; titleLabel.Parent = titleBar; titleLabel.Text = "NiggaLOSE v7.0" -- MODIFIED: Name Change
local titleLabelXOffset = titleBarPadding + logoSize + titleBarPadding; local titleLabelWidthReduction = titleLabelXOffset + (websiteLabelWidth + titleBarPadding + logoSize + titleBarPadding)
titleLabel.Position = UDim2.new(0, titleLabelXOffset, 0, 0); titleLabel.Size = UDim2.new(1, -titleLabelWidthReduction, 1, 0)
titleLabel.TextColor3 = theme.TextPrimary; -- Adjusted for visibility on red
titleLabel.Font = Enum.Font.GothamSemibold; titleLabel.TextSize = 16; titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.BackgroundTransparency = 1

local tabsFrame = Instance.new("Frame")
tabsFrame.Name = "TabsFrame"; tabsFrame.Parent = mainFrame; tabsFrame.Size = UDim2.new(0, 120, 1, -30); tabsFrame.Position = UDim2.new(0, 0, 0, 30)
tabsFrame.BackgroundColor3 = theme.LighterBackground; tabsFrame.BorderSizePixel = 0

local contentArea = Instance.new("Frame")
contentArea.Name = "ContentArea"; contentArea.Parent = mainFrame; contentArea.Size = UDim2.new(1, -120, 1, -30); contentArea.Position = UDim2.new(0, 120, 0, 30)
contentArea.BackgroundColor3 = theme.Background; contentArea.BorderSizePixel = 0

local tabCategories = {"瞄準", "透視", "移動", "雜項", "設定"}; local tabButtons = {}; local contentFrames = {}; local contentListFrames = {}; local activeTab = nil
local itemPadding = 8; local itemHeight = 28; local keyDisplayWidth = 60; local changeButtonWidth = 45; local checkboxWidth = 30;
local searchBoxHeight = 25; local searchBoxPadding = 5

local function createContentFrame(categoryName)
    local scrollFrame = Instance.new("ScrollingFrame"); scrollFrame.Name = categoryName .. "Content"; scrollFrame.Parent = contentArea
    scrollFrame.Size = UDim2.new(1, 0, 1, 0); scrollFrame.BackgroundTransparency = 1; scrollFrame.BorderSizePixel = 0; scrollFrame.Visible = false; scrollFrame.ScrollBarThickness = 6
    scrollFrame.ScrollBarImageColor3 = theme.Accent; -- MODIFIED: Scrollbar color
    scrollFrame.ScrollingDirection = Enum.ScrollingDirection.Y
    local listContentFrame = Instance.new("Frame"); listContentFrame.Name = "ListContent"; listContentFrame.Parent = scrollFrame
    listContentFrame.Size = UDim2.new(1, 0, 0, 0); listContentFrame.AutomaticSize = Enum.AutomaticSize.Y; listContentFrame.BackgroundTransparency = 1
    local listLayout = Instance.new("UIListLayout"); listLayout.Parent = listContentFrame; listLayout.Padding = UDim.new(0, itemPadding); listLayout.SortOrder = Enum.SortOrder.LayoutOrder; listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    local paddingInstance = Instance.new("UIPadding"); paddingInstance.Parent = listContentFrame; paddingInstance.PaddingTop = UDim.new(0, 10); paddingInstance.PaddingLeft = UDim.new(0, 15); paddingInstance.PaddingRight = UDim.new(0, 15); paddingInstance.PaddingBottom = UDim.new(0, 10)
    return scrollFrame, listContentFrame
end

for i, categoryName in ipairs(tabCategories) do
    local tabButton = Instance.new("TextButton"); tabButton.Name = categoryName .. "Tab"; tabButton.Parent = tabsFrame; tabButton.Size = UDim2.new(1, -10, 0, 35); tabButton.Position = UDim2.new(0, 5, 0, 5 + (i - 1) * (35 + 5))
    tabButton.Text = categoryName; tabButton.Font = Enum.Font.Gotham; tabButton.TextSize = 15; tabButton.TextColor3 = theme.TextSecondary; tabButton.BackgroundColor3 = theme.ElementBackground; tabButton.BorderSizePixel = 1; tabButton.BorderColor3 = theme.Border
    tabButtons[categoryName] = tabButton; local scrollContainerFrame, actualContentListFrame = createContentFrame(categoryName); contentFrames[categoryName] = scrollContainerFrame; contentListFrames[categoryName] = actualContentListFrame
    tabButton.MouseButton1Click:Connect(function()
        if activeTab and contentFrames[activeTab] then
            tabButtons[activeTab].TextColor3 = theme.TextSecondary
            tabButtons[activeTab].BackgroundColor3 = theme.ElementBackground
            if contentFrames[activeTab] then contentFrames[activeTab].Visible = false end
        end
        activeTab = categoryName
        tabButton.TextColor3 = theme.Accent
        tabButton.BackgroundColor3 = theme.Background -- Or a slightly lighter version of Background if preferred for active tab
        if contentFrames[categoryName] then contentFrames[categoryName].Visible = true end
        if categoryName == "設定" and updateFriendlyPlayersDisplay then
            updateFriendlyPlayersDisplay()
        end
    end)
end

-- Forward Declaration for Hitmarker Label access in Slider
local hitmarkerLabel

updateFriendlyPlayersDisplay = function()
    local friendlyListConfig = featuresConfig.friendly_players_list
    if not friendlyListConfig or not friendlyListConfig.ui or not friendlyListConfig.ui.scrollFrame or not friendlyListConfig.ui.searchBox then
        return
    end
    local scrollFrame = friendlyListConfig.ui.scrollFrame
    local searchBox = friendlyListConfig.ui.searchBox
    if not scrollFrame or not scrollFrame.Parent or not searchBox or not searchBox.Parent then
        warn("DEBUG: Friendly players UI elements not found or parented for update.")
        return
    end

    local searchTerm = string.lower(searchBox.Text or "")

    for _, child in ipairs(scrollFrame:GetChildren()) do
        if child:IsA("Frame") and child.Name == "PlayerEntryFrame" then
            child:Destroy()
        end
    end
    
    local layoutOrder = 1
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local playerDisplayNameLower = string.lower(player.DisplayName or "")
            local playerUsernameLower = string.lower(player.Name or "")

            if searchTerm == "" or string.find(playerDisplayNameLower, searchTerm, 1, true) or string.find(playerUsernameLower, searchTerm, 1, true) then
                local playerEntryFrame = Instance.new("Frame")
                playerEntryFrame.Name = "PlayerEntryFrame"
                playerEntryFrame.Parent = scrollFrame
                playerEntryFrame.Size = UDim2.new(1, 0, 0, itemHeight - 2)
                playerEntryFrame.BackgroundTransparency = 1
                playerEntryFrame.LayoutOrder = layoutOrder
                layoutOrder = layoutOrder + 1

                local playerNameLabel = Instance.new("TextLabel")
                playerNameLabel.Name = player.UserId .. "_FriendlyLabel"
                playerNameLabel.Parent = playerEntryFrame
                playerNameLabel.Size = UDim2.new(1, -(checkboxWidth + itemPadding + 5), 1, 0)
                playerNameLabel.Position = UDim2.new(0, 0, 0, 0)
                playerNameLabel.Font = Enum.Font.SourceSans
                playerNameLabel.TextSize = 13
                playerNameLabel.TextColor3 = theme.TextPrimary
                playerNameLabel.Text = player.DisplayName .. " (@" .. player.Name .. ")" -- MODIFIED: DisplayName (@Username)
                playerNameLabel.TextXAlignment = Enum.TextXAlignment.Left
                playerNameLabel.BackgroundTransparency = 1
                playerNameLabel.TextTruncate = Enum.TextTruncate.AtEnd

                local checkboxButton = Instance.new("TextButton")
                checkboxButton.Name = player.UserId .. "_FriendlyCheckbox"
                checkboxButton.Parent = playerEntryFrame
                checkboxButton.Size = UDim2.new(0, checkboxWidth, 1, 0)
                checkboxButton.Position = UDim2.new(1, -checkboxWidth, 0, 0)
                checkboxButton.BackgroundColor3 = theme.ElementBackground
                checkboxButton.BorderSizePixel = 1
                checkboxButton.BorderColor3 = theme.Border
                checkboxButton.Font = Enum.Font.SourceSansBold
                checkboxButton.TextSize = 16
                checkboxButton.TextColor3 = friendlyPlayersState[player] and theme.CheckboxChecked or theme.CheckboxUnchecked
                checkboxButton.Text = friendlyPlayersState[player] and "X" or ""

                checkboxButton.MouseButton1Click:Connect(function()
                    friendlyPlayersState[player] = not friendlyPlayersState[player]
                    checkboxButton.TextColor3 = friendlyPlayersState[player] and theme.CheckboxChecked or theme.CheckboxUnchecked
                    checkboxButton.Text = friendlyPlayersState[player] and "X" or ""
                end)
            end
        end
    end
end


local function populateFeatureUI(config, parentFrame)
    if config.id == "friendly_players_list" then
        local containerFrame = Instance.new("Frame")
        containerFrame.Name = "FriendlyPlayersContainer"
        containerFrame.Parent = parentFrame
        containerFrame.Size = UDim2.new(1, 0, 0, 230)
        containerFrame.BackgroundTransparency = 1
        containerFrame.LayoutOrder = #parentFrame:GetChildren() + 1
        
        local listTitle = Instance.new("TextLabel")
        listTitle.Name = "FriendlyListTitle"
        listTitle.Parent = containerFrame
        listTitle.Size = UDim2.new(1, 0, 0, 20)
        listTitle.Position = UDim2.new(0,0,0,0)
        listTitle.Font = Enum.Font.SourceSansSemibold
        listTitle.TextSize = 14
        listTitle.TextColor3 = theme.TextSecondary
        listTitle.Text = config.displayName
        listTitle.TextXAlignment = Enum.TextXAlignment.Left
        listTitle.BackgroundTransparency = 1
        
        local searchBox = Instance.new("TextBox")
        searchBox.Name = "FriendlySearchBox"
        searchBox.Parent = containerFrame
        searchBox.Size = UDim2.new(1, 0, 0, searchBoxHeight)
        searchBox.Position = UDim2.new(0, 0, 0, 20 + searchBoxPadding)
        searchBox.BackgroundColor3 = theme.ElementBackground
        searchBox.BorderColor3 = theme.Border
        searchBox.BorderSizePixel = 1
        searchBox.Font = Enum.Font.SourceSans
        searchBox.TextSize = 14
        searchBox.TextColor3 = theme.TextPrimary
        searchBox.Text = "" 
        searchBox.PlaceholderText = "搜索玩家 (顯示名稱/使用者名稱)..." 
        searchBox.PlaceholderColor3 = theme.SearchBoxPlaceholder
        searchBox.ClearTextOnFocus = false
        config.ui.searchBox = searchBox

        local scroll = Instance.new("ScrollingFrame")
        scroll.Name = "FriendlyPlayersScroll"
        scroll.Parent = containerFrame
        scroll.Size = UDim2.new(1, 0, 1, -(20 + searchBoxPadding + searchBoxHeight + searchBoxPadding))
        scroll.Position = UDim2.new(0,0,0, 20 + searchBoxPadding + searchBoxHeight + searchBoxPadding)
        scroll.BackgroundColor3 = theme.ElementBackground
        scroll.BorderColor3 = theme.Border
        scroll.BorderSizePixel = 1
        scroll.ScrollBarThickness = 5
        scroll.ScrollBarImageColor3 = theme.Accent
        config.ui.scrollFrame = scroll

        local listLayout = Instance.new("UIListLayout")
        listLayout.Parent = scroll
        listLayout.Padding = UDim.new(0, 3)
        listLayout.SortOrder = Enum.SortOrder.LayoutOrder
        listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        
        local padding = Instance.new("UIPadding")
        padding.Parent = scroll
        padding.PaddingTop = UDim.new(0,5)
        padding.PaddingLeft = UDim.new(0,5)
        padding.PaddingRight = UDim.new(0,5)
        padding.PaddingBottom = UDim.new(0,5)

        searchBox.FocusLost:Connect(function(enterPressed)
            -- Optional: if enterPressed and updateFriendlyPlayersDisplay then updateFriendlyPlayersDisplay() end
        end)
        searchBox:GetPropertyChangedSignal("Text"):Connect(function()
            if updateFriendlyPlayersDisplay then updateFriendlyPlayersDisplay() end
        end)
        
        if updateFriendlyPlayersDisplay then updateFriendlyPlayersDisplay() end
        return
    end


    if config.currentKey and config.id ~= "gui_toggle" and config.id ~= "active_features_gui_toggle" and config.id ~= "aimbot_module" and config.id ~= "esp_module" and config.id ~= "triggerbot_module" and config.id ~= "hitmarker" then
        local itemFrame = Instance.new("Frame"); itemFrame.Name = config.id .. "ItemFrame"; itemFrame.Parent = parentFrame; itemFrame.Size = UDim2.new(1, 0, 0, itemHeight); itemFrame.BackgroundTransparency = 1; itemFrame.LayoutOrder = #parentFrame:GetChildren() + 1
        local nameLabel = Instance.new("TextLabel"); nameLabel.Name = config.id .. "NameLabel"; nameLabel.Parent = itemFrame; nameLabel.Size = UDim2.new(1, - (keyDisplayWidth + changeButtonWidth + itemPadding * 2), 1, 0); nameLabel.Position = UDim2.new(0,0,0,0); nameLabel.Text = config.displayName; nameLabel.Font = Enum.Font.SourceSans; nameLabel.TextSize = 14; nameLabel.TextColor3 = theme.TextPrimary; nameLabel.TextXAlignment = Enum.TextXAlignment.Left; config.ui.nameLabel = nameLabel
        local keyDisplay = Instance.new("TextLabel"); keyDisplay.Name = config.id .. "KeyDisplay"; keyDisplay.Parent = itemFrame; keyDisplay.Size = UDim2.new(0, keyDisplayWidth, 1, 0); keyDisplay.Position = UDim2.new(1, -(keyDisplayWidth + changeButtonWidth + itemPadding), 0, 0); keyDisplay.BackgroundColor3 = theme.ElementBackground; keyDisplay.BorderColor3 = theme.Border; keyDisplay.BorderSizePixel = 1; keyDisplay.TextColor3 = theme.KeybindText; keyDisplay.Font = Enum.Font.SourceSansSemibold; keyDisplay.TextSize = 13; keyDisplay.Text = getKeyName(config.currentKey); keyDisplay.TextXAlignment = Enum.TextXAlignment.Center; config.ui.keyDisplayLabel = keyDisplay; updateFeatureKeyDisplay(config)
        local changeButton = Instance.new("TextButton"); changeButton.Name = config.id .. "ChangeKeyButton"; changeButton.Parent = itemFrame; changeButton.Size = UDim2.new(0, changeButtonWidth, 1, 0); changeButton.Position = UDim2.new(1, -changeButtonWidth, 0, 0); changeButton.BackgroundColor3 = theme.ElementBackground; changeButton.BorderSizePixel = 1; changeButton.BorderColor3 = theme.Border; changeButton.TextColor3 = theme.TextPrimary; changeButton.Font = Enum.Font.SourceSans; changeButton.TextSize = 14; changeButton.Text = "綁定"; config.ui.changeKeyButton = changeButton
        changeButton.MouseButton1Click:Connect(function()
            if currentlyBindingFeature then local oC = featuresConfig[currentlyBindingFeature]; if oC and oC.ui.changeKeyButton then oC.ui.changeKeyButton.Text = "綁定"; oC.ui.changeKeyButton.BackgroundColor3 = theme.ElementBackground; oC.ui.changeKeyButton.BorderColor3 = theme.Border; oC.ui.changeKeyButton.TextColor3 = theme.TextPrimary; end end
            currentlyBindingFeature = config.id; changeButton.Text = "按..."; changeButton.BackgroundColor3 = theme.Accent; changeButton.TextColor3 = theme.TextPrimary; changeButton.BorderColor3 = theme.Accent;
        end)
    end
    if config.isEnabled ~= nil then
        local toggleButton = Instance.new("TextButton"); toggleButton.Name = config.id .. "ToggleButton"; toggleButton.Parent = parentFrame; toggleButton.Size = UDim2.new(1, 0, 0, itemHeight); toggleButton.BackgroundColor3 = theme.ElementBackground; toggleButton.BorderSizePixel = 1; toggleButton.BorderColor3 = theme.Border; toggleButton.Font = Enum.Font.SourceSansSemibold; toggleButton.TextSize = 14; toggleButton.LayoutOrder = #parentFrame:GetChildren() + 1; config.ui.toggleButton = toggleButton; updateFeatureToggleButton(config)
        toggleButton.MouseButton1Click:Connect(function() config.isEnabled = not config.isEnabled; updateFeatureToggleButton(config); if config.onToggle then pcall(config.onToggle, config, config.isEnabled) end end)
    end
    local sliderMin, sliderMax, sliderCurrent, sliderIdPrefix, sliderLabelText, configValueKey
    if config.id == "flight_mode" then sliderMin, sliderMax, sliderCurrent, sliderIdPrefix, sliderLabelText, configValueKey = MIN_FLIGHT_SPEED, MAX_FLIGHT_SPEED, config.currentSpeed, "FlightSpeed", "飛行速度:", "currentSpeed"
    elseif config.id == "bhop_mode" then sliderMin, sliderMax, sliderCurrent, sliderIdPrefix, sliderLabelText, configValueKey = MIN_AIR_STRAFE_FORCE, MAX_AIR_STRAFE_FORCE, config.currentAirStrafeForce, "BhopForce", "連跳力度:", "currentAirStrafeForce"
    elseif config.id == "third_person" then sliderMin, sliderMax, sliderCurrent, sliderIdPrefix, sliderLabelText, configValueKey = MIN_THIRD_PERSON_DISTANCE_Z, MAX_THIRD_PERSON_DISTANCE_Z, config.currentDistanceZ, "TPDistance", "第三人稱距離:", "currentDistanceZ"
    elseif config.id == "teleport_mode" then sliderMin, sliderMax, sliderCurrent, sliderIdPrefix, sliderLabelText, configValueKey = MIN_TELEPORT_BEHIND_DISTANCE, MAX_TELEPORT_BEHIND_DISTANCE, config.currentTeleportDistance, "TPBehindDist", "背後距離:", "currentTeleportDistance"
    elseif config.id == "anti_aim" then sliderMin, sliderMax, sliderCurrent, sliderIdPrefix, sliderLabelText, configValueKey = MIN_ANTI_AIM_RADIUS, MAX_ANTI_AIM_RADIUS, config.currentAntiAimRadius, "AARadius", "隨機半徑:", "currentAntiAimRadius"
    elseif config.id == "triggerbot_module" then sliderMin, sliderMax, sliderCurrent, sliderIdPrefix, sliderLabelText, configValueKey = MIN_TRIGGERBOT_DELAY_MS, MAX_TRIGGERBOT_DELAY_MS, config.currentDelayMs, "TriggerDelay", "開槍延遲 (ms):", "currentDelayMs"
    elseif config.id == "hitmarker" then sliderMin, sliderMax, sliderCurrent, sliderIdPrefix, sliderLabelText, configValueKey = MIN_HITMARKER_SIZE, MAX_HITMARKER_SIZE, config.currentHitmarkerSize, "HitmarkerSize", "命中標記大小:", "currentHitmarkerSize"
    end
    if sliderMin then
        local sliderFrame = Instance.new("Frame"); sliderFrame.Name = sliderIdPrefix .. "SliderFrame"; sliderFrame.Parent = parentFrame; sliderFrame.Size = UDim2.new(1, 0, 0, itemHeight + 15); sliderFrame.BackgroundTransparency = 1; sliderFrame.LayoutOrder = #parentFrame:GetChildren() + 1
        local label = Instance.new("TextLabel"); label.Parent = sliderFrame; label.Size = UDim2.new(1,0,0,15); label.Position = UDim2.new(0,0,0,0); label.Text = sliderLabelText; label.Font = Enum.Font.SourceSans; label.TextSize = 13; label.TextColor3 = theme.TextSecondary; label.TextXAlignment = Enum.TextXAlignment.Left; label.BackgroundTransparency = 1
        local sliderTrack = Instance.new("Frame"); sliderTrack.Name = sliderIdPrefix .. "SliderTrack"; sliderTrack.Parent = sliderFrame; local valueDisplayWidth = 45; local sidePadding = 5; local trackWidth = parentFrame.AbsoluteSize.X - valueDisplayWidth - sidePadding - 30; if trackWidth <= 50 then trackWidth = math.max(50, parentFrame.AbsoluteSize.X * 0.6) end; sliderTrack.Size = UDim2.new(0, trackWidth, 0, 8); sliderTrack.Position = UDim2.new(0, 0, 0, 15 + (itemHeight-8)/2); sliderTrack.BackgroundColor3 = theme.ElementBackground; sliderTrack.BorderSizePixel = 1; sliderTrack.BorderColor3 = theme.Border
        local cr = Instance.new("UICorner"); cr.Parent = sliderTrack; cr.CornerRadius = UDim.new(0,4); config.ui[sliderIdPrefix .. "SliderTrack"] = sliderTrack
        local sliderThumb = Instance.new("Frame"); sliderThumb.Name = sliderIdPrefix .. "SliderThumb"; sliderThumb.Parent = sliderTrack; sliderThumb.Size = UDim2.new(0, 10, 1, 4); sliderThumb.Position = UDim2.new(0,0,0,-2); sliderThumb.BackgroundColor3 = theme.Accent; sliderThumb.BorderSizePixel = 0; local tc = Instance.new("UICorner"); tc.Parent = sliderThumb; tc.CornerRadius = UDim.new(0,3); config.ui[sliderIdPrefix .. "SliderThumb"] = sliderThumb
        local valueDisplay = Instance.new("TextLabel"); valueDisplay.Name = sliderIdPrefix .. "ValueDisplay"; valueDisplay.Parent = sliderFrame; valueDisplay.Size = UDim2.new(0, valueDisplayWidth, 0, itemHeight); valueDisplay.Position = UDim2.new(0, trackWidth + sidePadding, 0, 15); valueDisplay.Font = Enum.Font.SourceSansSemibold; valueDisplay.TextSize = 13; valueDisplay.TextColor3 = theme.TextPrimary; valueDisplay.TextXAlignment = Enum.TextXAlignment.Right; valueDisplay.BackgroundTransparency = 1; config.ui[sliderIdPrefix .. "ValueDisplay"] = valueDisplay
        local function updateSliderDisplay(currentVal)
            local p = 0; if sliderMax > sliderMin then p = math.clamp((currentVal - sliderMin) / (sliderMax - sliderMin), 0, 1) end
            sliderThumb.Position = UDim2.new(p, -sliderThumb.AbsoluteSize.X * p, 0, -2)
            if config.id == "third_person" or config.id == "teleport_mode" or config.id == "anti_aim" then valueDisplay.Text = string.format("%.1f", currentVal) else valueDisplay.Text = tostring(math.floor(currentVal)) end
        end; updateSliderDisplay(sliderCurrent)
        local draggingSlider = false; sliderThumb.InputBegan:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 then draggingSlider = true; mainFrame.Draggable = false end end)
        UserInputService.InputEnded:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 then if draggingSlider then draggingSlider = false; mainFrame.Draggable = true end end end)
        UserInputService.InputChanged:Connect(function(i)
            if draggingSlider and i.UserInputType == Enum.UserInputType.MouseMovement then
                local mX = UserInputService:GetMouseLocation().X; local tSX = sliderTrack.AbsolutePosition.X; local tAW = sliderTrack.AbsoluteSize.X; if tAW == 0 then return end; local rX = mX - tSX; local p = math.clamp(rX / tAW, 0, 1); local nV = sliderMin + (sliderMax - sliderMin) * p
                if configValueKey then config[configValueKey] = nV end; updateSliderDisplay(nV)
                if config.id == "hitmarker" and hitmarkerLabel then
                    local newSize = math.floor(nV)
                    hitmarkerLabel.TextSize = newSize
                    hitmarkerLabel.Size = UDim2.fromOffset(newSize, newSize)
                end
            end
        end)
    end
end

-- ========== GUI Creation (Visual Cue Dot) ==========
print("DEBUG: Creating Visual Cue GUI...")
local cueGui=Instance.new("ScreenGui"); cueGui.Name="AimbotVisualCueGui"; cueGui.ResetOnSpawn=false; cueGui.IgnoreGuiInset=true; cueGui.ZIndexBehavior=Enum.ZIndexBehavior.Global; cueGui.DisplayOrder=1000; cueGui.Parent=CoreGui
local cueDot=Instance.new("Frame"); cueDot.Name="CueDot"; cueDot.Size=UDim2.fromOffset(DOT_SIZE.X,DOT_SIZE.Y); cueDot.AnchorPoint=Vector2.new(0.5,0.5); cueDot.Position=UDim2.new(0.5,0,0.5,0); cueDot.BackgroundColor3=DOT_COLOR_NOLOCK; cueDot.BorderSizePixel=0; cueDot.Visible=true; cueDot.Parent=cueGui
local dotCorner=Instance.new("UICorner"); dotCorner.CornerRadius=UDim.new(0.5,0); dotCorner.Parent=cueDot
print("DEBUG: Visual Cue GUI created.")

-- ========== GUI Creation (Hitmarker) ==========
print("DEBUG: Creating Hitmarker GUI...")
local hitmarkerScreenGui = Instance.new("ScreenGui")
hitmarkerScreenGui.Name = "NiggaLOSE_HitmarkerDisplay" -- MODIFIED
hitmarkerScreenGui.ResetOnSpawn = false
hitmarkerScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
hitmarkerScreenGui.IgnoreGuiInset = true
hitmarkerScreenGui.DisplayOrder = 2000
hitmarkerScreenGui.Parent = PlayerGui

hitmarkerLabel = Instance.new("TextLabel")
hitmarkerLabel.Name = "HitmarkerX"
hitmarkerLabel.Size = UDim2.fromOffset(featuresConfig.hitmarker.currentHitmarkerSize, featuresConfig.hitmarker.currentHitmarkerSize)
hitmarkerLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
hitmarkerLabel.AnchorPoint = Vector2.new(0.5, 0.5)
hitmarkerLabel.BackgroundTransparency = 1
hitmarkerLabel.Font = Enum.Font.SourceSansBold
hitmarkerLabel.Text = HITMARKER_TEXT
hitmarkerLabel.TextColor3 = HITMARKER_COLOR
hitmarkerLabel.TextSize = featuresConfig.hitmarker.currentHitmarkerSize
hitmarkerLabel.TextStrokeColor3 = HITMARKER_OUTLINE_COLOR
hitmarkerLabel.TextStrokeTransparency = 0
hitmarkerLabel.Visible = false
hitmarkerLabel.Parent = hitmarkerScreenGui
print("DEBUG: Hitmarker GUI created.")


-- Populate Main UI Tabs after all base UI is ready
for id, config in pairs(featuresConfig) do
    local category = config.category or "雜項"; if contentListFrames[category] then populateFeatureUI(config, contentListFrames[category]) else warn("DEBUG: No content list frame for category:", category, "for feature:", id) end
end

if #tabCategories > 0 then
    local firstCategory = tabCategories[1]; if tabButtons[firstCategory] and contentFrames[firstCategory] then
        activeTab = firstCategory
        tabButtons[firstCategory].TextColor3 = theme.Accent
        tabButtons[firstCategory].BackgroundColor3 = theme.Background
        contentFrames[firstCategory].Visible = true
    end
    if firstCategory == "設定" and updateFriendlyPlayersDisplay then
        updateFriendlyPlayersDisplay()
    end
end
print("DEBUG: Main GUI content populated.")

-- ========== Active Features Display GUI ==========
print("DEBUG: Creating Active Features Display GUI...")
local activeFeaturesScreenGui = Instance.new("ScreenGui")
activeFeaturesScreenGui.Name = "NiggaLOSE_ActiveFeatures"; -- MODIFIED
activeFeaturesScreenGui.ResetOnSpawn = false; activeFeaturesScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling; activeFeaturesScreenGui.DisplayOrder = 100; activeFeaturesScreenGui.Parent = PlayerGui
local activeFeaturesFrame = Instance.new("Frame")
activeFeaturesFrame.Name = "ActiveFeaturesFrame"; activeFeaturesFrame.Size = UDim2.new(0, 200, 0, 30); activeFeaturesFrame.Position = UDim2.new(0, 10, 0, mainFrame.Size.Y.Offset + 20 + 10)
activeFeaturesFrame.BackgroundColor3 = theme.LighterBackground; activeFeaturesFrame.BorderColor3 = theme.Border; activeFeaturesFrame.BorderSizePixel = 1; activeFeaturesFrame.Active = true; activeFeaturesFrame.Draggable = true; activeFeaturesFrame.Parent = activeFeaturesScreenGui
activeFeaturesFrame.AutomaticSize = Enum.AutomaticSize.Y; activeFeaturesFrame.Visible = activeFeaturesGuiVisible
local activeFeaturesTitle = Instance.new("TextLabel")
activeFeaturesTitle.Name = "ActiveTitle"; activeFeaturesTitle.Parent = activeFeaturesFrame; activeFeaturesTitle.Size = UDim2.new(1, 0, 0, 20); activeFeaturesTitle.BackgroundColor3 = theme.Accent; activeFeaturesTitle.Text = "啟用中功能"; activeFeaturesTitle.Font = Enum.Font.SourceSansSemibold; activeFeaturesTitle.TextSize = 13; activeFeaturesTitle.TextColor3 = theme.TextPrimary; activeFeaturesTitle.TextXAlignment = Enum.TextXAlignment.Center; activeFeaturesTitle.BackgroundTransparency = 0;
local activeFeaturesListLayout = Instance.new("UIListLayout")
activeFeaturesListLayout.Parent = activeFeaturesFrame; activeFeaturesListLayout.Padding = UDim.new(0, 3); activeFeaturesListLayout.SortOrder = Enum.SortOrder.LayoutOrder; activeFeaturesListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center; activeFeaturesListLayout.FillDirection = Enum.FillDirection.Vertical
local activeFeaturesPadding = Instance.new("UIPadding")
activeFeaturesPadding.Parent = activeFeaturesFrame; activeFeaturesPadding.PaddingTop = UDim.new(0, 20 + 3); activeFeaturesPadding.PaddingBottom = UDim.new(0, 5); activeFeaturesPadding.PaddingLeft = UDim.new(0, 5); activeFeaturesPadding.PaddingRight = UDim.new(0, 5)
updateActiveFeaturesDisplay = function()
    if not activeFeaturesFrame or not activeFeaturesFrame.Parent then return end
    for _, child in ipairs(activeFeaturesFrame:GetChildren()) do if child:IsA("TextLabel") and child ~= activeFeaturesTitle then child:Destroy() end end
    local anyFeatureActive = false
    for id, config in pairs(featuresConfig) do
        if config.isEnabled and config.showInActiveList then
            local featureLabel = Instance.new("TextLabel"); featureLabel.Name = id .. "ActiveLabel"; featureLabel.Parent = activeFeaturesFrame; featureLabel.Size = UDim2.new(1, -10, 0, 18); featureLabel.Text = "- " .. config.displayName; featureLabel.Font = Enum.Font.SourceSans; featureLabel.TextSize = 12; featureLabel.TextColor3 = theme.ActiveListText; featureLabel.TextXAlignment = Enum.TextXAlignment.Left; featureLabel.BackgroundTransparency = 1; featureLabel.LayoutOrder = #activeFeaturesFrame:GetChildren(); anyFeatureActive = true
        end
    end; activeFeaturesFrame.Visible = activeFeaturesGuiVisible and anyFeatureActive
end; print("DEBUG: Active Features Display GUI created.")

-- Helper Functions (Existing + Hitmarker's findNearestEnemy)
setFlightPhysics = function(enabled) local localChar=LocalPlayer.Character; local hrp=localChar and localChar:FindFirstChild("HumanoidRootPart"); local h=localChar and localChar:FindFirstChildOfClass("Humanoid"); if not hrp or not h then return end; if enabled then if not bodyGyro or not bodyGyro.Parent then if bodyGyro then bodyGyro:Destroy() end; bodyGyro=Instance.new("BodyGyro"); bodyGyro.P=5000; bodyGyro.MaxTorque=Vector3.new(9e9,9e9,9e9); bodyGyro.CFrame=hrp.CFrame; bodyGyro.Parent=hrp end; if not bodyVelocity or not bodyVelocity.Parent then if bodyVelocity then bodyVelocity:Destroy() end; bodyVelocity=Instance.new("BodyVelocity"); bodyVelocity.P=1250; bodyVelocity.MaxForce=Vector3.new(9e9,9e9,9e9); bodyVelocity.Velocity=Vector3.new(0,0,0); bodyVelocity.Parent=hrp end; h.AutoRotate=false else if bodyGyro then bodyGyro:Destroy(); bodyGyro=nil end; if bodyVelocity then bodyVelocity:Destroy(); bodyVelocity=nil end; h.AutoRotate=true end end
restoreCamera = function() Camera.CameraType = originalCameraType; pcall(function() Camera.Focus = originalCameraFocus end); lastThirdPersonPos = nil; end
setNoclipState = function(enabled) local c=LocalPlayer.Character; if not c then return end; local h=c:FindFirstChildOfClass("Humanoid"); if not h then return end; if enabled then if h:GetState()~=Enum.HumanoidStateType.Physics then h:ChangeState(Enum.HumanoidStateType.Physics) end; task.wait(); for _,p in ipairs(c:GetDescendants())do if p:IsA("BasePart")then p.CanCollide=false end end else for _,p in ipairs(c:GetDescendants())do if p:IsA("BasePart")then p.CanCollide=true end end; if h:GetState()==Enum.HumanoidStateType.Physics then h:ChangeState(Enum.HumanoidStateType.GettingUp)end end end
destroyGhostModel = function(reason) if ghostModel then pcall(function() ghostModel:Destroy() end); ghostModel = nil end; cframeHistory = {}; lastAppliedDelayedCFrame = nil; end
createOrUpdateGhostModel = function() local c=LocalPlayer.Character; if not c then destroyGhostModel("Char nil"); return false end; local hrp=c:FindFirstChild("HumanoidRootPart"); if not hrp then destroyGhostModel("HRP nil"); return false end; if not ghostModel or not ghostModel.Parent then if ghostModel then pcall(function() ghostModel:Destroy() end) end; ghostModel=Instance.new("Model"); ghostModel.Name="LocalGhost_"..LocalPlayer.UserId; ghostModel.Archivable=false; local pc,ghc=0,false; for _,p in ipairs(c:GetChildren())do if p:IsA("BasePart")or p:IsA("MeshPart")then local gp=p:Clone(); gp.Name="Ghost_"..p.Name; gp.Anchored=true; gp.CanCollide=false; gp.CastShadow=false; pcall(function()gp.Transparency=GHOST_TRANSPARENCY end); for _,ch in ipairs(gp:GetChildren())do if ch:IsA("Decal")or ch:IsA("Texture")then ch:Destroy()end end; gp.Parent=ghostModel; pc=pc+1; if p.Name=="HumanoidRootPart"then ghostModel.PrimaryPart=gp; ghc=true end elseif p:IsA("Accessory")then local ga=p:Clone(); ga.Name="Ghost_"..p.Name; if ga:FindFirstChild("Handle")and ga.Handle:IsA("BasePart")then local h=ga.Handle; h.Anchored=true;h.CanCollide=false;pcall(function()h.Transparency=GHOST_TRANSPARENCY end)end; ga.Parent=ghostModel; pc=pc+1 end end; if pc>0 and ghc then ghostModel.Parent=Workspace else destroyGhostModel("Clone fail");return false end end; if ghostModel and ghostModel.PrimaryPart then pcall(function()ghostModel:SetPrimaryPartCFrame(hrp.CFrame)end)else destroyGhostModel("SetCF fail");return false end; return true end
local function updateFakeLagLogic() if not featuresConfig.fake_lag.isEnabled then if ghostModel then destroyGhostModel("FL off") end return end; local c=LocalPlayer.Character; local hrp=c and c:FindFirstChild("HumanoidRootPart"); if not c or not hrp then destroyGhostModel("No char/hrp FL"); return end; if hrp.Anchored then hrp.Anchored=false end; if not createOrUpdateGhostModel() then return end; local cf,t=hrp.CFrame,tick(); table.insert(cframeHistory,{t=t,cf=cf}); local oR,rI=nil,0; for i=1,#cframeHistory do local r=cframeHistory[i]; if t-r.t>=GHOST_DELAY_SECONDS then oR=r;rI=i-1 else break end end; if rI>0 then for i=1,rI do table.remove(cframeHistory,1)end end; local tCF=oR and oR.cf; if tCF then if not lastAppliedDelayedCFrame or (tCF.Position-lastAppliedDelayedCFrame.Position).Magnitude>0.01 or(t-lastRealCFrameAppliedTime>=MIN_REAL_CFRAME_UPDATE_INTERVAL)then if pcall(function()hrp.CFrame=CFrame.new(tCF.Position)*(hrp.CFrame-hrp.CFrame.Position)end)then lastRealCFrameAppliedTime=t;lastAppliedDelayedCFrame=tCF end end else lastAppliedDelayedCFrame=nil end; if #cframeHistory>200 then table.remove(cframeHistory,1)end end
onBhopJumpRequest = function() if not featuresConfig.bhop_mode.isEnabled then return end; local c=LocalPlayer.Character; local h=c and c:FindFirstChildOfClass("Humanoid"); if not h then return end; if h:GetState()~=Enum.HumanoidStateType.Jumping and h:GetState()~=Enum.HumanoidStateType.Freefall and h.FloorMaterial~=Enum.Material.Air then h.Jump=true; isBhopJumping=true; canBhopAirStrafe=true end end
onBhopHumanoidStateChanged = function(o,n) if not featuresConfig.bhop_mode.isEnabled then return end; local c=LocalPlayer.Character; local h=c and c:FindFirstChildOfClass("Humanoid"); if not h then return end; if n==Enum.HumanoidStateType.Landed then isBhopJumping=false; canBhopAirStrafe=false elseif n==Enum.HumanoidStateType.Jumping or n==Enum.HumanoidStateType.Freefall then isBhopJumping=true; canBhopAirStrafe=true end end
connectBhopStateChanged = function() if bhopStateChangedConnection then return end; local c=LocalPlayer.Character; local h=c and c:FindFirstChildOfClass("Humanoid"); if h then bhopStateChangedConnection=h.StateChanged:Connect(onBhopHumanoidStateChanged); local cs=h:GetState(); if cs==Enum.HumanoidStateType.Jumping or cs==Enum.HumanoidStateType.Freefall then isBhopJumping=true;canBhopAirStrafe=true else isBhopJumping=false;canBhopAirStrafe=false end else warn("BHOP: Hum not found")end end
disconnectBhopStateChanged = function() if bhopStateChangedConnection then bhopStateChangedConnection:Disconnect(); bhopStateChangedConnection=nil end; isBhopJumping=false; canBhopAirStrafe=false end
createEspForPlayer = function(p)
    if not DrawingLib then return end
    if espElements[p] then return end
    local e = {}
    e.Box = DrawingLib.new("Quad"); e.Box.Color = ESP_BOX_COLOR; e.Box.Thickness = 1; e.Box.Filled = false; e.Box.Visible = false
    e.Name = DrawingLib.new("Text"); e.Name.Text = p.DisplayName .. " (@" .. p.Name .. ")"; e.Name.Color = ESP_TEXT_COLOR; e.Name.Size = ESP_TEXT_SIZE; e.Name.Center = true; e.Name.Outline = true; e.Name.Visible = false
    e.Health = DrawingLib.new("Text"); e.Health.Text = "100/100"; e.Health.Color = ESP_TEXT_COLOR; e.Health.Size = ESP_HEALTH_SIZE; e.Health.Center = true; e.Health.Outline = true; e.Health.Visible = false
    espElements[p] = e
end
removeEspForPlayer = function(p) if espElements[p]then local e=espElements[p]; if e.Box then e.Box:Remove()end; if e.Name then e.Name:Remove()end; if e.Health then e.Health:Remove()end; espElements[p]=nil end end

getNearestPlayerAbsolute = function()
    local cp, sd = nil, math.huge
    local lc = LocalPlayer.Character
    local lHRP = lc and lc:FindFirstChild("HumanoidRootPart")
    if not lc or not lHRP then return nil end
    for _, p in pairs(Players:GetPlayers()) do
        if p == LocalPlayer or friendlyPlayersState[p] == true then continue end
        local c = p.Character
        local ht = c and c:FindFirstChild("HumanoidRootPart")
        local h = c and c:FindFirstChild("Head")
        local hum = c and c:FindFirstChildOfClass("Humanoid")
        if ht and h and hum and hum.Health > 0 then
            local d = (ht.Position - lHRP.Position).Magnitude
            if d < sd then sd = d; cp = p end
        end
    end
    return cp
end

getNearestVisiblePlayer = function()
    local cp, sd = nil, math.huge
    local lc = LocalPlayer.Character
    local lHRP = lc and lc:FindFirstChild("HumanoidRootPart")
    if not lc or not lHRP then return nil end
    for _, p in pairs(Players:GetPlayers()) do
        if p == LocalPlayer or friendlyPlayersState[p] == true then continue end
        local c = p.Character
        local ht = c and c:FindFirstChild("HumanoidRootPart")
        local h_part = c and c:FindFirstChild("Head")
        local hum = c and c:FindFirstChildOfClass("Humanoid")
        if ht and h_part and hum and hum.Health > 0 then
            local d = (ht.Position - lHRP.Position).Magnitude
            if d < sd then
                local ro = Camera.CFrame.Position
                local rd = (h_part.Position - ro).Unit * d
                local rp = RaycastParams.new()
                local fl = {lc, Camera, controlPanelGui, cueGui, activeFeaturesScreenGui, hitmarkerScreenGui}
                if ghostModel and ghostModel.Parent then table.insert(fl, ghostModel) end
                rp.FilterDescendantsInstances = fl
                rp.FilterType = Enum.RaycastFilterType.Exclude
                local rr = Workspace:Raycast(ro, rd, rp)
                if not rr or rr.Instance:IsDescendantOf(c) then sd = d; cp = p end
            end
        end
    end
    return cp
end

local function teleportBehindPlayer(tp) local lc=LocalPlayer.Character; local tc=tp.Character; if not lc or not tc then return end; local hrp=lc:FindFirstChild("HumanoidRootPart"); local thrp=tc:FindFirstChild("HumanoidRootPart"); if not hrp or not thrp then return end; hrp.CFrame=thrp.CFrame*CFrame.new(0,0,featuresConfig.teleport_mode.currentTeleportDistance)*CFrame.Angles(0,math.pi,0) end
local function teleportRandomlyAroundPlayer(tp) local lc=LocalPlayer.Character; local tc=tp.Character; if not lc or not tc then return end; local hrp=lc:FindFirstChild("HumanoidRootPart"); local thrp=tc:FindFirstChild("HumanoidRootPart"); if not hrp or not thrp then return end; local ra=math.random()*2*math.pi; local r=featuresConfig.anti_aim.currentAntiAimRadius; hrp.CFrame=thrp.CFrame*CFrame.new(math.cos(ra)*r,0,math.sin(ra)*r)end

findNearestEnemy = function()
    local nearestPlayer, nearestHumanoid, minDist = nil, nil, math.huge
    local localChar, localHRP = LocalPlayer.Character, LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not localChar or not localHRP then return nil, nil end
    local localPos = localHRP.Position

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local char, humanoid, hrp = player.Character, player.Character and player.Character:FindFirstChildOfClass("Humanoid"), player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if char and humanoid and hrp and humanoid.Health > 0 then
                local dist = (hrp.Position - localPos).Magnitude
                if dist < minDist then minDist, nearestPlayer, nearestHumanoid = dist, player, humanoid end
            end
        end
    end
    return nearestPlayer, nearestHumanoid
end

-- ====================================
-- Main Update Loop (RenderStepped)
-- ====================================
local rsConn
rsConn = RunService.RenderStepped:Connect(function(deltaTime)
    local success, err = pcall(function()
        local localChar = LocalPlayer.Character
        local hrp = localChar and localChar:FindFirstChild("HumanoidRootPart")
        local charHead = localChar and localChar:FindFirstChild("Head")
        local humanoid = localChar and localChar:FindFirstChildOfClass("Humanoid")
        if not hrp or not humanoid then return end
        local currentTime = tick()

        if featuresConfig.fake_lag.isEnabled then updateFakeLagLogic() end

        if humanoid and not featuresConfig.flight_mode.isEnabled and not featuresConfig.bhop_mode.isEnabled and not featuresConfig.teleport_mode.isEnabled and not featuresConfig.anti_aim.isEnabled and humanoid.AutoRotate == false then humanoid.AutoRotate = true end

        local nearestMovementTarget = nil; if featuresConfig.teleport_mode.isEnabled or featuresConfig.anti_aim.isEnabled then nearestMovementTarget = getNearestPlayerAbsolute() end

        if featuresConfig.flight_mode.isEnabled then
            if humanoid.AutoRotate == true then humanoid.AutoRotate = false end; local mv=Vector3.new(0,0,0); if UserInputService:IsKeyDown(Enum.KeyCode.W)then mv=mv+Vector3.new(0,0,-1)end; if UserInputService:IsKeyDown(Enum.KeyCode.S)then mv=mv+Vector3.new(0,0,1)end; if UserInputService:IsKeyDown(Enum.KeyCode.A)then mv=mv+Vector3.new(-1,0,0)end; if UserInputService:IsKeyDown(Enum.KeyCode.D)then mv=mv+Vector3.new(1,0,0)end; local vv=0; if UserInputService:IsKeyDown(Enum.KeyCode.Space)then vv=FLIGHT_VERTICAL_SPEED end; if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)or UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)then vv=-FLIGHT_VERTICAL_SPEED end; local cwV; local hd=(Camera.CFrame*CFrame.new(mv)).Position-Camera.CFrame.Position; local hsc=Vector3.new(0,0,0); if hd.Magnitude>0.001 then hsc=Vector3.new(hd.X,0,hd.Z).Unit*featuresConfig.flight_mode.currentSpeed end; cwV=hsc+Vector3.new(0,vv,0); if bodyVelocity then bodyVelocity.Velocity=cwV end; if bodyGyro then bodyGyro.CFrame=Camera.CFrame end
        elseif featuresConfig.bhop_mode.isEnabled and canBhopAirStrafe and isBhopJumping then
            if humanoid.AutoRotate==true then humanoid.AutoRotate=false end; local md=Vector3.new(); if UserInputService:IsKeyDown(Enum.KeyCode.W)then md=md+Camera.CFrame.LookVector end; if UserInputService:IsKeyDown(Enum.KeyCode.S)then md=md-Camera.CFrame.LookVector end; if UserInputService:IsKeyDown(Enum.KeyCode.A)then md=md-Camera.CFrame.RightVector end; if UserInputService:IsKeyDown(Enum.KeyCode.D)then md=md+Camera.CFrame.RightVector end; if md.Magnitude>0.01 then local af=featuresConfig.bhop_mode.currentAirStrafeForce; local da=Vector3.new(md.X,0,md.Z).Unit*af; local cv=hrp.Velocity; local nx=cv.X+da.X*deltaTime; local nz=cv.Z+da.Z*deltaTime; hrp.Velocity=Vector3.new(nx,cv.Y,nz); local csxz=Vector3.new(hrp.Velocity.X,0,hrp.Velocity.Z); if csxz.Magnitude>MAX_BHOP_AIR_SPEED then local d=csxz.Unit; hrp.Velocity=Vector3.new(d.X*MAX_BHOP_AIR_SPEED,hrp.Velocity.Y,d.Z*MAX_BHOP_AIR_SPEED)end end
        elseif featuresConfig.anti_aim.isEnabled and nearestMovementTarget then if humanoid.AutoRotate==true then humanoid.AutoRotate=false end; teleportRandomlyAroundPlayer(nearestMovementTarget)
        elseif featuresConfig.teleport_mode.isEnabled and nearestMovementTarget then if humanoid.AutoRotate==true then humanoid.AutoRotate=false end; pcall(teleportBehindPlayer, nearestMovementTarget) end

        local calculatedCameraCFrame=nil
        if featuresConfig.third_person.isEnabled then
            local cc=LocalPlayer.Character; local a=(cc and cc:FindFirstChild("Head"))or hrp; if a then local ap=a.Position; local rc=Camera.CFrame; local ctdz=featuresConfig.third_person.currentDistanceZ; local dp=ap+(-rc.LookVector.Unit*ctdz)+(rc.RightVector.Unit*THIRD_PERSON_OFFSET_XY.X)+(rc.UpVector.Unit*THIRD_PERSON_OFFSET_XY.Y); local roc=ap; local rdc=(dp-ap); local rdst=rdc.Magnitude; if rdst<0.1 then rdst=ctdz end; rdc=rdc.Unit; local rpc=RaycastParams.new(); local flc={cc,controlPanelGui,cueGui,activeFeaturesScreenGui,hitmarkerScreenGui}; if ghostModel and ghostModel.Parent then table.insert(flc,ghostModel)end; rpc.FilterDescendantsInstances=flc; rpc.FilterType=Enum.RaycastFilterType.Exclude; local hr=Workspace:Raycast(roc,rdc*rdst,rpc); if hr then dp=hr.Position-rdc*0.5 end; if not lastThirdPersonPos then lastThirdPersonPos=dp end; lastThirdPersonPos=lastThirdPersonPos:Lerp(dp,1-THIRD_PERSON_SMOOTHING); local lat=(charHead or hrp).Position+(charHead or hrp).CFrame.LookVector*5; calculatedCameraCFrame=CFrame.new(lastThirdPersonPos,lat); if Camera.CameraType~=Enum.CameraType.Scriptable then Camera.CameraType=Enum.CameraType.Scriptable end end
        end

        local isAiming=false; if featuresConfig.aimbot_hold.currentKey then if featuresConfig.aimbot_hold.currentKey:IsA("UserInputType")then isAiming=UserInputService:IsMouseButtonPressed(featuresConfig.aimbot_hold.currentKey)elseif featuresConfig.aimbot_hold.currentKey:IsA("KeyCode")then isAiming=UserInputService:IsKeyDown(featuresConfig.aimbot_hold.currentKey)end end

        local aimbotTargetPlayer=nil; local aimbotOverrideCFrame=nil; local isLocked=false
        if featuresConfig.aimbot_module.isEnabled and isAiming then
            aimbotTargetPlayer=getNearestVisiblePlayer();
            if aimbotTargetPlayer then local th=aimbotTargetPlayer.Character and aimbotTargetPlayer.Character:FindFirstChild("Head"); if th then isLocked=true; local afp=featuresConfig.third_person.isEnabled and lastThirdPersonPos or Camera.CFrame.Position; aimbotOverrideCFrame=CFrame.new(afp,th.Position); if Camera.CameraType~=Enum.CameraType.Scriptable then Camera.CameraType=Enum.CameraType.Scriptable end end end
        end
        
        if aimbotOverrideCFrame then calculatedCameraCFrame=aimbotOverrideCFrame end
        if calculatedCameraCFrame then pcall(function()Camera.CFrame=calculatedCameraCFrame end)elseif not featuresConfig.third_person.isEnabled and Camera.CameraType==Enum.CameraType.Scriptable then if not(featuresConfig.aimbot_module.isEnabled and isAiming)then if restoreCamera then restoreCamera()end end end
        
        cueDot.BackgroundColor3=isLocked and DOT_COLOR_LOCKED or DOT_COLOR_NOLOCK

        -- Shooting Logic
        local doShootActionThisFrame=false; local triggerbotConfig=featuresConfig.triggerbot_module; local actualTriggerDelaySec=triggerbotConfig.currentDelayMs/1000
        local isTryingToShootThisFrame=isLocked and((triggerbotConfig.isEnabled and isAiming)or(not triggerbotConfig.isEnabled and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)))
        local startedTryingToShootThisFrame=isTryingToShootThisFrame and not wasTryingToShootLastFrame
        if startedTryingToShootThisFrame then lastClickTime=currentTime end
        if isTryingToShootThisFrame then if currentTime-lastClickTime>=actualTriggerDelaySec then doShootActionThisFrame=true end end
        if doShootActionThisFrame then if typeof(mouse1press)=="function"then pcall(mouse1press)end; if typeof(mouse1release)=="function"then task.defer(mouse1release)end; lastClickTime=currentTime end
        wasTryingToShootLastFrame=isTryingToShootThisFrame

        -- ESP Logic
        if featuresConfig.esp_module.isEnabled and DrawingLib then for _,p in pairs(Players:GetPlayers())do if p==LocalPlayer then continue end; local ce=p.Character; local he=ce and ce:FindFirstChildOfClass("Humanoid"); local hrpe=ce and ce:FindFirstChild("HumanoidRootPart"); local heade=ce and ce:FindFirstChild("Head"); if he and hrpe and heade and he.Health>0 then if not espElements[p]then createEspForPlayer(p)end; local els=espElements[p]; if not els then continue end; els.Name.Text = p.DisplayName .. " (@" .. p.Name .. ")"; local hp,hv=Camera:WorldToViewportPoint(heade.Position+Vector3.new(0,0.5,0)); local hrpp,hrpv=Camera:WorldToViewportPoint(hrpe.Position); if hv and hrpv then local bh=math.abs(hp.Y-hrpp.Y); local bw=bh/2; local tl=Vector2.new(hp.X-bw/2,hp.Y); els.Box.Color = ESP_BOX_COLOR; els.Name.Color = ESP_TEXT_COLOR; els.Health.Color = ESP_TEXT_COLOR; els.Box.PointA=tl; els.Box.PointB=Vector2.new(tl.X+bw,tl.Y); els.Box.PointC=Vector2.new(tl.X+bw,hrpp.Y); els.Box.PointD=Vector2.new(tl.X,hrpp.Y); els.Box.Visible=true; els.Name.Position=Vector2.new(hp.X,hp.Y-ESP_TEXT_SIZE-2); els.Name.Visible=true; local ht=math.floor(he.Health).."/"..math.floor(he.MaxHealth); els.Health.Text=ht; els.Health.Position=Vector2.new(hrpp.X,hrpp.Y+2); els.Health.Visible=true else els.Box.Visible=false; els.Name.Visible=false; els.Health.Visible=false end else if espElements[p]then local e=espElements[p]; e.Box.Visible=false; e.Name.Visible=false; e.Health.Visible=false end end end
        else if next(espElements)then for _,es in pairs(espElements)do if es.Box then es.Box.Visible=false end; if es.Name then es.Name.Visible=false end; if es.Health then es.Health.Visible=false end end end end

        -- Hitmarker Tracking Logic
        if featuresConfig.hitmarker.isEnabled and hitmarkerLabel.Visible then
            if tick() > hitmarkerVisibleUntil then
                hitmarkerLabel.Visible = false
                currentHitTarget = nil
            elseif currentHitTarget then
                local targetChar = currentHitTarget.Character
                local targetPart = targetChar and (targetChar:FindFirstChild("Head") or targetChar:FindFirstChild("HumanoidRootPart"))
                if targetPart and targetChar.Parent and targetPart.Parent == targetChar and targetChar:FindFirstChildOfClass("Humanoid") and targetChar:FindFirstChildOfClass("Humanoid").Health > 0 then
                    local screenPos, onScreen = Workspace.CurrentCamera:WorldToViewportPoint(targetPart.Position)
                    if onScreen then
                        hitmarkerLabel.Position = UDim2.fromOffset(screenPos.X, screenPos.Y)
                    else
                        hitmarkerLabel.Visible = false; currentHitTarget = nil
                    end
                else
                    hitmarkerLabel.Visible = false; currentHitTarget = nil
                end
            end
        end

    end)
    if not success then warn("DEBUG: ERROR in RenderStepped:", err, debug.traceback(err)) end
end)
print("DEBUG: RenderStepped connected.")

-- ========== Hitmarker Health Check (Heartbeat) ==========
local hitmarkerCheckConn
hitmarkerCheckConn = RunService.Heartbeat:Connect(function(dt)
     if featuresConfig.hitmarker.isEnabled and tick() - lastHealthCheckTime >= HITMARKER_CHECK_INTERVAL then
        local nearestEnemyPlayer, nearestEnemyHumanoid = findNearestEnemy()

        if nearestEnemyPlayer and nearestEnemyHumanoid then
            local currentHealth = nearestEnemyHumanoid.Health
            local previousHealth = lastCheckedHealth[nearestEnemyPlayer]

            if previousHealth == nil then
                lastCheckedHealth[nearestEnemyPlayer] = currentHealth
            else
                if currentHealth < previousHealth then
                    currentHitTarget = nearestEnemyPlayer
                    local currentSize = featuresConfig.hitmarker.currentHitmarkerSize
                    hitmarkerLabel.TextSize = currentSize
                    hitmarkerLabel.Size = UDim2.fromOffset(currentSize, currentSize)

                    local enemyChar = nearestEnemyPlayer.Character
                    local enemyPart = enemyChar and (enemyChar:FindFirstChild("Head") or enemyChar:FindFirstChild("HumanoidRootPart"))
                    if enemyPart then
                        local screenPos, onScreen = Workspace.CurrentCamera:WorldToViewportPoint(enemyPart.Position)
                        if onScreen then
                            hitmarkerLabel.Position = UDim2.fromOffset(screenPos.X, screenPos.Y)
                            hitmarkerLabel.Visible = true
                            hitmarkerVisibleUntil = tick() + HITMARKER_DURATION
                        else
                            currentHitTarget = nil
                        end
                    else
                         currentHitTarget = nil
                    end
                end
                lastCheckedHealth[nearestEnemyPlayer] = currentHealth
            end
        end
        lastHealthCheckTime = tick()
     end
end)
print("DEBUG: Hitmarker Heartbeat connected.")


-- ========== Player Added/Removed Handlers ==========
print("DEBUG: Connecting Player Handlers (ESP, Hitmarker & Friendly List)...")
Players.PlayerAdded:Connect(function(p)
    if DrawingLib then createEspForPlayer(p) end
    if updateFriendlyPlayersDisplay then
        updateFriendlyPlayersDisplay()
    end
    -- Update ESP name for the new player if it was created before DisplayName was available
    if espElements[p] and espElements[p].Name then
        espElements[p].Name.Text = p.DisplayName .. " (@" .. p.Name .. ")"
    end
end)

Players.PlayerRemoving:Connect(function(p)
    removeEspForPlayer(p)
    if lastCheckedHealth[p] then
        lastCheckedHealth[p] = nil
    end
    if currentHitTarget == p then
        currentHitTarget = nil
        hitmarkerLabel.Visible = false
    end
    if friendlyPlayersState[p] ~= nil then
        friendlyPlayersState[p] = nil
    end
    if updateFriendlyPlayersDisplay then
        updateFriendlyPlayersDisplay()
    end
end)

-- Initialize ESP for existing players
if DrawingLib then for _,p in pairs(Players:GetPlayers())do if p~=LocalPlayer then createEspForPlayer(p)end end end
print("DEBUG: Initial players processed for ESP.")
if updateFriendlyPlayersDisplay then
    task.wait(0.1)
    updateFriendlyPlayersDisplay()
    print("DEBUG: Initial friendly players list processed (DisplayName/@Username + search + placeholder).")
end


-- ========== Character Added/Removed Handlers ==========
print("DEBUG: Connecting Character Handlers...")
LocalPlayer.CharacterAdded:Connect(function(nc)
    if destroyGhostModel then destroyGhostModel("New char")end
    if featuresConfig.fake_lag.isEnabled and LocalPlayer.Character==nc then task.wait(0.1); if createOrUpdateGhostModel then createOrUpdateGhostModel()end end
    if featuresConfig.flight_mode.isEnabled then task.wait(0.2); if setNoclipState then setNoclipState(true)end; if setFlightPhysics then setFlightPhysics(true)end end
    if featuresConfig.bhop_mode.isEnabled then task.wait(0.1); if connectBhopStateChanged then connectBhopStateChanged()end end
    if hitmarkerLabel then hitmarkerLabel.Visible = false end
    currentHitTarget = nil
end)

LocalPlayer.CharacterRemoving:Connect(function(oc)
    if destroyGhostModel then destroyGhostModel("Char removed")end
    if featuresConfig.flight_mode.isEnabled and setFlightPhysics then setFlightPhysics(false)end
    if disconnectBhopStateChanged then disconnectBhopStateChanged()end
end)
print("DEBUG: Character Handlers connected.")

-- ========== Input Handling ==========
print("DEBUG: Connecting Input Handling...")
local inputConn
inputConn = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    local friendlySearchBox = featuresConfig.friendly_players_list and featuresConfig.friendly_players_list.ui and featuresConfig.friendly_players_list.ui.searchBox
    if friendlySearchBox and friendlySearchBox:IsFocused() and input.KeyCode ~= CANCEL_BIND_KEY then
        if not (currentlyBindingFeature and input.KeyCode == CANCEL_BIND_KEY) then
            return
        end
    end

    if currentlyBindingFeature then
        if input.KeyCode == CANCEL_BIND_KEY then resetButtonStates(); return end; local conf=featuresConfig[currentlyBindingFeature]; if not conf then resetButtonStates(); return end; local nkC=nil; local iR=false
        if input.UserInputType==Enum.UserInputType.Keyboard then nkC=input.KeyCode; local k=input.KeyCode; if k==Enum.KeyCode.LeftShift or k==Enum.KeyCode.RightShift or k==Enum.KeyCode.LeftControl or k==Enum.KeyCode.RightControl or k==Enum.KeyCode.Tab or k==CANCEL_BIND_KEY then iR=true end
        elseif input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.MouseButton2 or input.UserInputType==Enum.UserInputType.MouseButton3 then nkC=input.UserInputType
        else resetButtonStates(); return end; if not iR and nkC then for id,c in pairs(featuresConfig)do if id~=currentlyBindingFeature and c.currentKey==nkC then iR=true;break end end end; if iR then return end
        if nkC then conf.currentKey=nkC; if updateFeatureKeyDisplay then updateFeatureKeyDisplay(conf)end end; resetButtonStates(); return
    end

    if featuresConfig.bhop_mode and featuresConfig.bhop_mode.isEnabled and input.KeyCode==Enum.KeyCode.Space then if not gameProcessedEvent then if onBhopJumpRequest then onBhopJumpRequest()end end end

    local isAimbotHoldKey = featuresConfig.aimbot_hold and featuresConfig.aimbot_hold.currentKey and ((input.UserInputType==Enum.UserInputType.Keyboard and input.KeyCode==featuresConfig.aimbot_hold.currentKey)or(input.UserInputType~=Enum.UserInputType.Keyboard and input.UserInputType==featuresConfig.aimbot_hold.currentKey))
    local isGuiToggleKey = featuresConfig.gui_toggle and featuresConfig.gui_toggle.currentKey and input.KeyCode==featuresConfig.gui_toggle.currentKey
    local isActiveListToggleKey = featuresConfig.active_features_gui_toggle and featuresConfig.active_features_gui_toggle.currentKey and input.KeyCode==featuresConfig.active_features_gui_toggle.currentKey

    if gameProcessedEvent and not isAimbotHoldKey and not isGuiToggleKey and not isActiveListToggleKey then return end
    
    for fid,cfg in pairs(featuresConfig)do if cfg.currentKey and((input.UserInputType==Enum.UserInputType.Keyboard and input.KeyCode==cfg.currentKey)or(input.UserInputType~=Enum.UserInputType.Keyboard and input.UserInputType==cfg.currentKey))then
        if gameProcessedEvent and fid~="gui_toggle" and fid~="active_features_gui_toggle" and fid~="aimbot_hold" then return end

        if fid=="gui_toggle" then cfg.isEnabled=not cfg.isEnabled; if mainFrame then mainFrame.Visible=cfg.isEnabled end; UserInputService.MouseIconEnabled=(cfg.isEnabled or(featuresConfig.active_features_gui_toggle.isEnabled and activeFeaturesFrame and activeFeaturesFrame.Visible)); if cfg.isEnabled then UserInputService.MouseBehavior=Enum.MouseBehavior.Default else if not(featuresConfig.active_features_gui_toggle.isEnabled and activeFeaturesFrame and activeFeaturesFrame.Visible)then UserInputService.MouseBehavior=Enum.MouseBehavior.LockCenter end end; if cfg.onToggle then pcall(cfg.onToggle,cfg,cfg.isEnabled)end; if updateFeatureToggleButton then updateFeatureToggleButton(cfg)end
        elseif fid=="active_features_gui_toggle" then cfg.isEnabled=not cfg.isEnabled; activeFeaturesGuiVisible=cfg.isEnabled; if activeFeaturesFrame then activeFeaturesFrame.Visible=activeFeaturesGuiVisible and(#activeFeaturesFrame:GetChildren()>3)end; if updateActiveFeaturesDisplay then updateActiveFeaturesDisplay()end; UserInputService.MouseIconEnabled=(featuresConfig.gui_toggle.isEnabled or(cfg.isEnabled and activeFeaturesFrame and activeFeaturesFrame.Visible)); if cfg.isEnabled and activeFeaturesFrame and activeFeaturesFrame.Visible then UserInputService.MouseBehavior=Enum.MouseBehavior.Default else if not featuresConfig.gui_toggle.isEnabled then UserInputService.MouseBehavior=Enum.MouseBehavior.LockCenter end end; if updateFeatureToggleButton then updateFeatureToggleButton(cfg)end
        elseif fid=="aimbot_hold" then
        else cfg.isEnabled=not cfg.isEnabled; if updateFeatureToggleButton then updateFeatureToggleButton(cfg)end; if cfg.onToggle then pcall(cfg.onToggle,cfg,cfg.isEnabled)end end
        return
    end end
end)
print("DEBUG: Input Handling connected (with search box focus check).")

-- ========== Initialization ==========
if mainFrame then mainFrame.Visible = featuresConfig.gui_toggle.isEnabled end
if activeFeaturesFrame then activeFeaturesFrame.Visible = activeFeaturesGuiVisible end
updateActiveFeaturesDisplay()

if featuresConfig.hitmarker.onToggle then
     pcall(featuresConfig.hitmarker.onToggle, featuresConfig.hitmarker, featuresConfig.hitmarker.isEnabled)
end

UserInputService.MouseIconEnabled = (featuresConfig.gui_toggle.isEnabled or (featuresConfig.active_features_gui_toggle.isEnabled and activeFeaturesFrame and activeFeaturesFrame.Visible))
if UserInputService.MouseIconEnabled then UserInputService.MouseBehavior = Enum.MouseBehavior.Default else UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter end

-- Cleanup function
local function cleanup()
    print("DEBUG: Script cleanup initiated (NiggaLOSE v7.0)...") -- MODIFIED
    if rsConn then rsConn:Disconnect(); rsConn=nil end
    if hitmarkerCheckConn then hitmarkerCheckConn:Disconnect(); hitmarkerCheckConn=nil end
    if inputConn then inputConn:Disconnect(); inputConn=nil end
    if setFlightPhysics then setFlightPhysics(false)end; if setNoclipState then setNoclipState(false)end
    if disconnectBhopStateChanged then disconnectBhopStateChanged()end; if destroyGhostModel then destroyGhostModel("Script cleanup")end
    for p,_ in pairs(espElements)do removeEspForPlayer(p)end;
    if controlPanelGui and controlPanelGui.Parent then controlPanelGui:Destroy()end
    if activeFeaturesScreenGui and activeFeaturesScreenGui.Parent then activeFeaturesScreenGui:Destroy()end
    if cueGui and cueGui.Parent then cueGui:Destroy()end
    if hitmarkerScreenGui and hitmarkerScreenGui.Parent then hitmarkerScreenGui:Destroy() end
    if featuresConfig.third_person.isEnabled and restoreCamera then pcall(restoreCamera)end
    local c=LocalPlayer.Character; local h=c and c:FindFirstChildOfClass("Humanoid"); if h and h.AutoRotate==false then if not featuresConfig.flight_mode.isEnabled and not featuresConfig.bhop_mode.isEnabled then h.AutoRotate=true end end
    UserInputService.MouseIconEnabled=true; UserInputService.MouseBehavior=Enum.MouseBehavior.Default; print("DEBUG: Cleanup complete (NiggaLOSE v7.0).") -- MODIFIED
end

if script and typeof(script)=="Instance" then script.Destroying:Connect(cleanup)end
if featuresConfig.bhop_mode.isEnabled then if connectBhopStateChanged then connectBhopStateChanged()end end

print("DEBUG: NiggaLOSE v7.0 fully loaded and initialized with Red/Black Theme, Hitmarker, Friendly List (DisplayName/@Username), Search (Placeholder), and ESP (DisplayName/@Username) features.") -- MODIFIED
